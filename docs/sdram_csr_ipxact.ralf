system CPU0 {
    bytes 4;
    block ADDR_MAP @0x2400 {
        bytes 4;
        register CFG_MANUAL_ADDRESS_MAP @0x0 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field cfg_manual_address_map @'h0 {
                access rw;
                hard_reset 'h0;
                doc {
                    Enables user selection of address mapping
 
 0 - Default address mapping. Address mapping from l_addr based on settings of cfg_mem_rowbits, cfg_mem_colbits, as described in the SDRAM Controller User Guide.
 
 1 - User selected address mapping. Address mapping from l_addr based on settings of cfg_chipaddr_map, cfg_rowaddr_map, cfg_bankaddr_map, cfg_coladdr_map, and cfg_cidaddr_map (DDR4 3DS)

                }
            }
        }
        register CFG_MB_AUTOPCH_COL_BIT_POS_LOW @0xc {
            bytes 4;
            field reserved @'h3 {
                bits 29;
            }
            field cfg_mb_autopch_col_bit_pos_low @'h0 {
                bits 3;
                access rw;
                hard_reset 'h4;
                doc {
                    This field together with the cfg_mb_autopch_col_bit_pos_high field set a contiguous column address region that allows customization of when auto precharge occurs within multiburst accesses. cfg_mb_autopch_col_bit_pos_low sets the low bit position of l_addr and cfg_mb_autopch_col_bit_pos_high sets the high bit position of l_addr bits that are used to define the last column address in an open bank. When the multiburst internal l_addr bits in the l_addr range defined by these two configuration fields are all one, an auto_precharge will be issued by the multiburst module internally for the sub-access. This field is unused if cfg_manual_address_map is set to 0. Setting this field to 0 disables this auto-precharge functionality.  When it is used, the only valid values are a function of the memory technology being used as follows:

DDR3 -   3 or 4. (3 is normal default)

DDR4 -   3 or 4. (4 is normal default)

HBM  -   2,3,or 4 (4 is normal default)

                }
            }
        }
        register CFG_MB_AUTOPCH_COL_BIT_POS_HIGH @0x10 {
            bytes 4;
            field reserved @'h4 {
                bits 28;
            }
            field cfg_mb_autopch_col_bit_pos_high @'h0 {
                bits 4;
                access rw;
                hard_reset 'ha;
                doc {
                    This field together with the cfg_mb_autopch_col_bit_pos_low field set a contiguous column address region that allows customization of when auto precharge occurs within multiburst accesses. cfg_mb_autopch_col_bit_pos_low sets the low bit position of l_addr and cfg_mb_autopch_col_bit_pos_high sets the high bit position of l_addr bits that are used to define the last column address in an open bank. When the multiburst internal l_addr bits in the l_addr range defined by these two configuration fields are all one, an auto_precharge will be issued by the multiburst module internally for the sub-access. This field is unused if if cfg_manual_address_map is set to 0. When it is used, the only valid values are a function of the memory technology being used as follows:

DDR3 -   cfg_mem_colbits-1 to 4. (cfg_mem_colbits-1 is the normal default)

DDR4 -   10 to 4. (10 is the normal default)

HBM  -   8 to 4. (8 is the normal default)

                }
            }
        }
        register CFG_BANKADDR_MAP_0 @0x14 {
            bytes 4;
            field cfg_bankaddr_map_0 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Six 6-bit quantities specifying how to map address bits from l_addr into bank bits (sd_ba).
 
 bits 0-5 - Specify which bit of l_addr maps to bank address bit 0 (sd_ba[0])
 
 bits 6-11 - Specifies which bit of l_addr maps to bank address bit 1 (sd_ba[1])
 
 bits 12-17 - Specifies which bit of l_addr maps to bank address bit 2/group bit 0 (sd_ba[2], for HBM pseudo channel memory this is also the pseudo channel select bit)
 
 bits 18-23 - Specifies which bit of l_addr maps to bank address bit 3/group bit 1 (sd_ba[3])

 bits 24-29 - Specifies which bit of l_addr maps to bank address bit 4/group bit 2 (sd_ba[4])

 bits 30-35 - Specifies which bit of l_addr maps to bank address bit 5/group bit 3 (sd_ba[5], for HBM pseudo channel memory this is also the SID bank selection bit)

                }
            }
        }
        register CFG_BANKADDR_MAP_1 @0x18 {
            bytes 4;
            field reserved @'h4 {
                bits 28;
            }
            field cfg_bankaddr_map_1 @'h0 {
                bits 4;
                access rw;
                hard_reset 'h0;
                doc {
                    Six 6-bit quantities specifying how to map address bits from l_addr into bank bits (sd_ba).
 
 bits 0-5 - Specify which bit of l_addr maps to bank address bit 0 (sd_ba[0])
 
 bits 6-11 - Specifies which bit of l_addr maps to bank address bit 1 (sd_ba[1])
 
 bits 12-17 - Specifies which bit of l_addr maps to bank address bit 2/group bit 0 (sd_ba[2], for HBM pseudo channel memory this is also the pseudo channel select bit)
 
 bits 18-23 - Specifies which bit of l_addr maps to bank address bit 3/group bit 1 (sd_ba[3])

 bits 24-29 - Specifies which bit of l_addr maps to bank address bit 4/group bit 2 (sd_ba[4])

 bits 30-35 - Specifies which bit of l_addr maps to bank address bit 5/group bit 3 (sd_ba[5], for HBM pseudo channel memory this is also the SID bank selection bit)

                }
            }
        }
        register CFG_ROWADDR_MAP_0 @0x1c {
            bytes 4;
            field cfg_rowaddr_map_0 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Eighteen 6-bit quantities specifying how to map address bits from l_addr into row bits (sd_a, during activate command).
 
 bits 0-5 - Specify which bit of l_addr maps to row address bit 0
 
 bits 6-11 - Specifies which bit of l_addr maps to row address bit 1
 
 ...
 
 bits 6*x-6*x+5 - Specifies which bit of l_addr maps to row address bit x
 
 Note: When 6'd00 is used, it means a hard-coded zero (not l_addr[0]) except in the case where zero is used in the lower 9 rowaddr bit selections, in which case it refers to l_addr[0].

                }
            }
        }
        register CFG_ROWADDR_MAP_1 @0x20 {
            bytes 4;
            field cfg_rowaddr_map_1 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Eighteen 6-bit quantities specifying how to map address bits from l_addr into row bits (sd_a, during activate command).
 
 bits 0-5 - Specify which bit of l_addr maps to row address bit 0
 
 bits 6-11 - Specifies which bit of l_addr maps to row address bit 1
 
 ...
 
 bits 6*x-6*x+5 - Specifies which bit of l_addr maps to row address bit x
 
 Note: When 6'd00 is used, it means a hard-coded zero (not l_addr[0]) except in the case where zero is used in the lower 9 rowaddr bit selections, in which case it refers to l_addr[0].

                }
            }
        }
        register CFG_ROWADDR_MAP_2 @0x24 {
            bytes 4;
            field cfg_rowaddr_map_2 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Eighteen 6-bit quantities specifying how to map address bits from l_addr into row bits (sd_a, during activate command).
 
 bits 0-5 - Specify which bit of l_addr maps to row address bit 0
 
 bits 6-11 - Specifies which bit of l_addr maps to row address bit 1
 
 ...
 
 bits 6*x-6*x+5 - Specifies which bit of l_addr maps to row address bit x
 
 Note: When 6'd00 is used, it means a hard-coded zero (not l_addr[0]) except in the case where zero is used in the lower 9 rowaddr bit selections, in which case it refers to l_addr[0].

                }
            }
        }
        register CFG_ROWADDR_MAP_3 @0x28 {
            bytes 4;
            field reserved @'hc {
                bits 20;
            }
            field cfg_rowaddr_map_3 @'h0 {
                bits 12;
                access rw;
                hard_reset 'h0;
                doc {
                    Eighteen 6-bit quantities specifying how to map address bits from l_addr into row bits (sd_a, during activate command).
 
 bits 0-5 - Specify which bit of l_addr maps to row address bit 0
 
 bits 6-11 - Specifies which bit of l_addr maps to row address bit 1
 
 ...
 
 bits 6*x-6*x+5 - Specifies which bit of l_addr maps to row address bit x
 
 Note: When 6'd00 is used, it means a hard-coded zero (not l_addr[0]) except in the case where zero is used in the lower 9 rowaddr bit selections, in which case it refers to l_addr[0].

                }
            }
        }
        register CFG_COLADDR_MAP_0 @0x2c {
            bytes 4;
            field cfg_coladdr_map_0 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Sixteen 6-bit quantities specifying how to map address bits from l_addr into row bits (sd_a, during read/write commands).
 
 bits 0-5 - Specify which bit of l_addr maps to column address bit 0
 
 bits 6-11 - Specifies which bit of l_addr maps to column address bit 1
 
 ...
 
 bits 6*x-6*x+5 - Specifies which bit of l_addr maps to column address bit x
 
 Note: When 6'd00 is used, it means a hard-coded zero (not l_addr[0]) except in the case where zero is used in the lower 3 coladdr
 selections, in which case it refers to l_addr[0].

                }
            }
        }
        register CFG_COLADDR_MAP_1 @0x30 {
            bytes 4;
            field cfg_coladdr_map_1 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Sixteen 6-bit quantities specifying how to map address bits from l_addr into row bits (sd_a, during read/write commands).
 
 bits 0-5 - Specify which bit of l_addr maps to column address bit 0
 
 bits 6-11 - Specifies which bit of l_addr maps to column address bit 1
 
 ...
 
 bits 6*x-6*x+5 - Specifies which bit of l_addr maps to column address bit x
 
 Note: When 6'd00 is used, it means a hard-coded zero (not l_addr[0]) except in the case where zero is used in the lower 3 coladdr
 selections, in which case it refers to l_addr[0].

                }
            }
        }
        register CFG_COLADDR_MAP_2 @0x34 {
            bytes 4;
            field cfg_coladdr_map_2 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Sixteen 6-bit quantities specifying how to map address bits from l_addr into row bits (sd_a, during read/write commands).
 
 bits 0-5 - Specify which bit of l_addr maps to column address bit 0
 
 bits 6-11 - Specifies which bit of l_addr maps to column address bit 1
 
 ...
 
 bits 6*x-6*x+5 - Specifies which bit of l_addr maps to column address bit x
 
 Note: When 6'd00 is used, it means a hard-coded zero (not l_addr[0]) except in the case where zero is used in the lower 3 coladdr
 selections, in which case it refers to l_addr[0].

                }
            }
        }
    }
    block MC_BASE3 @0x2800 {
        bytes 4;
        register CFG_GENERATE_REFRESH_ON_SRX @0x24 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field cfg_generate_refresh_on_srx @'h0 {
                access rw;
                hard_reset 'h1;
                doc {
                    When exiting self-refresh the controller will wait for a refresh to occur before allowing normal memory requests to resume.  The controller can either generate the refresh request immediately or it can wait for the refresh timer to generate the refresh request naturally.  In typical systems the controller should be programmed to generate the refresh immediately (cfg_generate_refresh_on_srx=1) for low latency following self-refresh exit.  In some dual-controller systems it is advantageous to maintain synchronization in refresh requests and the cfg_generate_refresh_on_srx should be disabled (cfg_generate_refresh_on_srx=0) to allow the synchronized refresh timers to maintain refresh request synchronization.

                }
            }
        }
        register INIT_FORCE_WRITE_DATA_0 @0x30 {
            bytes 4;
            field init_force_write_data_0 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Data driven to memory device nibble lanes when init_force_write is asserted and a regular write is not being driven. Each bit corresponds to one nibble of the memory interface and drives all 4 bits of the corresponding nibble.
 
 Bit 0 - driven to DQ nibble [3:0]
 
 Bit 1 - driven to DQ nibble [7:4]
 
 ...
 
 Bit n-1 - driven to DQ nibble [n*4+3:n*4]

                }
            }
        }
        register CFG_12HI @0x3c {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field cfg_12hi @'h0 {
                access rw;
                hard_reset 'h0;
                doc {
                    This configuration bit is only supported by the NWL V2 controller and supports the JEDEC HBM2E 12Hi extended addressing capability.  When this bit is set, the controller supports 48 banks and 3 SID bank bit encodings: {2'b00, 2'b01, 2'b10}. 

                }
            }
        }
        register CFG_NP2_ROWS @0x40 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field cfg_np2_rows @'h0 {
                access rw;
                hard_reset 'h0;
                doc {
                    This configuration bit is only supported by the NWL V2 controller and supports the JEDEC HBM2E non-power of 2 rows addressing capability. When this bit is set, the controller supports 2^14 + 2^13 number of rows. Note that cfg_rowbits must also be set to a value of 14 for the this configuration bit to take effect.

                }
            }
        }
        register CFG_INTERLEAVE_FAW @0x44 {
            bytes 4;
            field reserved @'h4 {
                bits 28;
            }
            field cfg_interleave_faw @'h0 {
                bits 4;
                access rw;
                hard_reset 'h0;
                doc {
                    Interleaved four bank activate (counts activates/sbrefs from both pseudo channels), specified in  memory clocks. Only used for HBM_Gen2 option E deliveries and then only for one vendor and then only with the V2 version of the NWL controller. This field will be ignored if cfg_ps_one_faw is set to 0. Finally note that the vendor that requires this timing enforced also uses the name tFAWS for this timing parameter.

                }
            }
        }
        register CFG_AP_NOBANK_QLVL @0x48 {
            bytes 4;
            field reserved @'h2 {
                bits 30;
            }
            field cfg_ap_nobank_qlvl @'h0 {
                bits 2;
                access rw;
                hard_reset 'h2;
                doc {
                    This 2-bit field selects the number of valid entries that must be in the queue before enabling a "nobank-match" autoprecharge promotion. The queue levels needed to enable the no-bank autoprecharge promotion as function of the controller core's QUEUE_DEPTH are as follows:
 0x0 Disable no-bank autoprecharge promotion
 0x1 QUEUE_DEPTH/4
 0x2 QUEUE_DEPTH/2
 0x3 3/4*QUEUE_DEPTH (default)

Note that this configuration field is only supported by the V2 controller.

                }
            }
        }
    }
    block MC_BASE1 @0x3c00 {
        bytes 4;
        register CFG_TEMP_CTRL_REF_MODE @0x34 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field cfg_temp_ctrl_ref_mode @'h0 {
                access rw;
                hard_reset 'h1;
                doc {
                    Used to control refresh for DDR4 and self-refresh for HBM.

 For DDR4 temperature controlled refresh mode:
 
 0 - Disable temperature controlled refresh mode
 
 1 - Enable temperature controlled refresh mode

 For HBM temperature controlled self-refresh mode:  
 
 0 - Disable temperature compensated self-refresh mode
 
 1 - Enable temperature compensated self-refresh mode
 
 This bit is loaded into bit 2 (TCSR) of Mode register 0.

                }
            }
        }
        register CFG_READ_DBI @0x40 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field cfg_read_dbi @'h0 {
                access rw;
                hard_reset 'h1;
                doc {
                    Read data bus inversion (DBI):
 
 0 - Read DBI disabled
 
 1 - Read DBI enabled

                }
            }
        }
        register CFG_WRITE_DBI @0x44 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field cfg_write_dbi @'h0 {
                access rw;
                hard_reset 'h1;
                doc {
                    Write data bus inversion (DBI):
 
 0 - Write DBI disabled
 
 1 - Write DBI enabled

                }
            }
        }
        register CFG_DATA_MASK @0x48 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field cfg_data_mask @'h0 {
                access rw;
                hard_reset 'h0;
                doc {
                    Write data mask:
 
 0 - Write data mask disabled
 
 1 - Write data mask enabled

 For GDDR6 this enables the use of the write-with-single-byte-mask (WSM/A) and write-with-double-byte-mask (WDM/A) commands.

                }
            }
        }
        register CFG_CCD_S @0x64 {
            bytes 4;
            field reserved @'h3 {
                bits 29;
            }
            field cfg_ccd_s @'h0 {
                bits 3;
                access rw;
                hard_reset 'h2;
                doc {
                    SDRAM CAS_n-to-CAS_n delay for different bank group (tCCD_S), specified in memory clocks.  For HBM pseudo channel mode memory, this is tracked for each pseudo channel.

                }
            }
        }
        register CFG_CCD_L @0x68 {
            bytes 4;
            field reserved @'h4 {
                bits 28;
            }
            field cfg_ccd_l @'h0 {
                bits 4;
                access rw;
                hard_reset 'h4;
                doc {
                    SDRAM CAS_n-to-CAS_n delay for same bank group (tCCD_L), specified in memory clocks. This is tracked for each pseudo channel.

                }
            }
        }
        register CFG_RRD_S @0x78 {
            bytes 4;
            field reserved @'h5 {
                bits 27;
            }
            field cfg_rrd_s @'h0 {
                bits 5;
                access rw;
                hard_reset 'h3;
                doc {
                    SDRAM ACTIVATE-to-ACTIVATE command period for different bank group (tRRD_S), specified in memory clocks.

                }
            }
        }
        register CFG_RRD_L @0x7c {
            bytes 4;
            field reserved @'h5 {
                bits 27;
            }
            field cfg_rrd_l @'h0 {
                bits 5;
                access rw;
                hard_reset 'h3;
                doc {
                    SDRAM ACTIVATE-to-ACTIVATE command period for same group (tRRD_L), specified in memory clocks.

                }
            }
        }
        register CFG_WTR_S @0x80 {
            bytes 4;
            field reserved @'h4 {
                bits 28;
            }
            field cfg_wtr_s @'h0 {
                bits 4;
                access rw;
                hard_reset 'h5;
                doc {
                    SDRAM write to read command delay for different bank group (tWTR_S), specified in memory clocks.

                }
            }
        }
        register CFG_WTR_L @0x84 {
            bytes 4;
            field reserved @'h4 {
                bits 28;
            }
            field cfg_wtr_l @'h0 {
                bits 4;
                access rw;
                hard_reset 'h8;
                doc {
                    SDRAM write to read command delay for same bank group (tWTR_L), specified in memory clocks.

                }
            }
        }
        register CFG_RD_DQ_PARITY_EN @0xa0 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field cfg_rd_dq_parity_en @'h0 {
                access rw;
                hard_reset 'h1;
                doc {
                    Enables(1) or disables(0) HBM DQ read parity generation/checking.

                }
            }
        }
        register CFG_WR_DQ_PARITY_EN @0xa4 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field cfg_wr_dq_parity_en @'h0 {
                access rw;
                hard_reset 'h1;
                doc {
                    Enables(1) or disables(0) HBM DQ write parity generation/checking.

                }
            }
        }
        register CFG_CA_PARITY_EN @0xa8 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field cfg_ca_parity_en @'h0 {
                access rw;
                hard_reset 'h1;
                doc {
                    Enables(1) or disables(0) HBM row and column command/address parity checking.

                }
            }
        }
        register CFG_BANK_GROUP_EN @0xac {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field cfg_bank_group_en @'h0 {
                access rw;
                hard_reset 'h1;
                doc {
                    Enables(1) or disables(0) HBM bank groups. When bank groups are enabled, the upper bits of bank address bits become bank group bits as a function of the total number of bank bits defined by cfg_mem_bankbits (valid values of cfg_mem_bankbits are 3 to 6 only):

  3 -  bank-group bits: ba[2] 

  4 -  bank-group bits: ba[3:2]

  5 -  bank-group bits: ba[4:2]

  6 -  bank-group bits: ba[5:2]

 Enabling bank grouping is required for HBM devices operating at frequencies above fCKBG. Refer to HBM vendor datasheet for fCKBG value. 

                }
            }
        }
        register CFG_HBM_CB_EN @0xb0 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field cfg_hbm_cb_en @'h0 {
                access rw;
                hard_reset 'h1;
                doc {
                    Enables(1) or disables(0) HBM check-bit/byte memory. Note data-mask functionality (cfg_data_mask) can not be enabled, if check-bit functionality is enabled as well, since both functions use the same pin per byte. Note also that the check bit functionality can only be enabled if the HBM memory itself supports the check bit functionality.

                }
            }
        }
        register CFG_HBM_PARITY_LATENCY @0xb4 {
            bytes 4;
            field reserved @'h2 {
                bits 30;
            }
            field cfg_hbm_parity_latency @'h0 {
                bits 2;
                access rw;
                hard_reset 'h0;
                doc {
                    Sets the sd_clk latency for HBM DQ parity generation/checking when DQ parity checking is enabled.  Note, write data parity is sent from controller aligned to write data.  The PHY is expected to delay the write data parity before sending to memory device.  For reads, the PHY returns read data parity delayed relative to read data.  The amount of delay is as specified by cfg_hbm_parity_latency.
 
 0 - same timing as data
 
 1 - 1 sd_clk after data
 
 2 - 2 sd_clks after data
 
 3 - 3 sd_clks after data

                }
            }
        }
        register CFG_TCR_ENABLE @0xb8 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field cfg_tcr_enable @'h0 {
                access rw;
                hard_reset 'h1;
                doc {
                    Enables(1) or disables(0) HBM refresh period temperature compensation enable. When enabled, dfi_tcr_temp[2:0] inputs control the refresh interval that is used.
 dfi_tcr_temp[2:0] (Note this is defined in the HBM2 JEDEC specification but is repeated here using NWL nomenclature)

 000 -  refresh interval = 4 * cfg_ref_per

 001 -  refresh interval = 2 * cfg_ref_per

 011 -  refresh interval = 1 * cfg_ref_per

 010 -  refresh interval = cfg_ref_per/2

 110 -  refresh interval = cfg_ref_per/4

 default - refresh interval = 1 * cfg_ref_per

                }
            }
        }
        register STAT_WRITE_DATA_PARITY_ERROR @0xbc {
            bytes 4;
            field reserved @'h4 {
                bits 28;
            }
            field stat_write_data_parity_error @'h0 {
                bits 4;
                access rc;
                volatile 1
                hard_reset 'h0;
                doc {
                    DQ write parity error is set when a write DQ parity error occurs and is cleared when this register is read.  For HBM memory controllers with a single controller (Options D) there is one status bit per DWORD of channel data.  For dual-controller configurations (Option E) there is one status bit per DWORD for the respective pseudo channel.

If data parity error retry logic is included in the controller configuration, this will only get set on the last unsuccessful write data parity error retry attempt.

                }
            }
        }
        register STAT_READ_DATA_PARITY_ERROR @0xc0 {
            bytes 4;
            field reserved @'h4 {
                bits 28;
            }
            field stat_read_data_parity_error @'h0 {
                bits 4;
                access rc;
                volatile 1
                hard_reset 'h0;
                doc {
                    DQ read parity error is set when a read DQ parity error occurs and is cleared when this register is read.  For HBM memory controllers with a single controller (Options D) there is one status bit per DWORD of channel data.  For dual-controller configurations (Option E) there is one status bit per DWORD for the respective pseudo channel.

If data parity error retry logic is included in the controller configuration, this will only get set on the last unsuccessful read data parity error retry attempt.

                }
            }
        }
        register CFG_EN_RRDP @0xc8 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field cfg_en_rrdp @'h0 {
                access rw;
                hard_reset 'h1;
                doc {
                    Enables(1) or disables(0) HBM pseudo channel tRRDP = 2 timing. This only affects HBM2 pseudo channel devices: when this bit is enabled, the controller insures that there are at least
2 memory clocks between bank activations (single bank refresh counts as a bank activation command) when the activations are to different pseudo channels. Note that tRRD_S and tRRD_L still apply to 
bank activations within each pseudo channel (when staying within a pseudo channel). 

tRRDP is not defined by JEDEC and is only defined by one HBM vendor, and that vendor has indicated that it is not actually needed for production devices. Review vendor datasheet or contact vendor to determine if it is required.

It is only valid for cfg_en_rrdp to be set if cfg_ps_one_faw is also set.

                }
            }
        }
        register CFG_PS_ONE_FAW @0xcc {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field cfg_ps_one_faw @'h0 {
                access rw;
                hard_reset 'h0;
                doc {
                    When set to 1, only one FAW (four bank-activate window timing) counter is used to track bank activations (single bank refresh is a bank activation command as well) both HBM2 pseudo channels.  When set to 0, a FAW counter per pseudo-channel is used to track bank activations within the pseudo channel only. 

JEDEC defines that tFAW applies to each pseudo-channel independently. However one vendor has defined tFAW to apply to activates among both pseudo-channels.

                }
            }
        }
        register CFG_CCD_R @0xd0 {
            bytes 4;
            field reserved @'h3 {
                bits 29;
            }
            field cfg_ccd_r @'h0 {
                bits 3;
                access rw;
                hard_reset 'h4;
                doc {
                    HBM2 read to read delay when the SID bank bit toggles (tCCD_R), specified in memory clocks. Note that this is tracked and applies per pseudo channel.

 Valid values for this parameter are 2,3, and 4. If any other value is written to this register, the controller will override it and use 4 for the CCD_R value. 

                }
            }
        }
        register CFG_AUTO_MR_PROG_EN @0xd4 {
            bytes 4;
            field reserved @'h10 {
                bits 16;
            }
            field cfg_auto_mr_prog_en @'h0 {
                bits 16;
                access rw;
                hard_reset 'h805f;
                doc {
                    This 16-bit field selects which HBM or GDDR6 mode registers are programmed during the automatic mode register programming sequence that occurs after power-up. Each bit maps to the corresponding mode register (i.e. cfg_auto_mr_prog_en[0] = 1 means that MR0 will be programmed). This field defaults to 0x805F for HBM or 0x99BF for GDDR6.  This configuration option is available for HBM or GDDR6 deliveries only.

                }
            }
        }
        register CFG_INT_VREF @0xd8 {
            bytes 4;
            field reserved @'h3 {
                bits 29;
            }
            field cfg_int_vref @'h0 {
                bits 3;
                access rw;
                hard_reset 'h0;
                doc {
                    This 3-bit wide value defines the HBM2 VREF programming value for HBM2 mode register MR15, if cfg_auto_mr_prog_en enables programming this mode register. 

                }
            }
        }
        register CFG_DA28_LOCKOUT @0xdc {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field cfg_da28_lockout @'h0 {
                access rw;
                hard_reset 'h0;
                doc {
                    This 1-bit wide value is used to set HBM2's  DA[28] lockout programming value (MR8 bit 0), if cfg_auto_mr_prog_en enables programming this mode register. 

                }
            }
        }
        register CFG_SBREF_EN @0x278 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field cfg_sbref_en @'h0 {
                access rw;
                hard_reset 'h0;
                doc {
                    When the controller is configured to generate refreshes automatically (cfg_auto_ref_en = 1), this register controls whether all-bank refresh or single-bank refresh is used. When enabled (1), multiple single bank refresh commands are issued at every "refresh interval" (controlled by cfg_ref_per and dfi_tcr_temp, see cfg_auto_ref_en description). If disabled (0), refresh is performed using a precharge-all (if required) and all-bank refresh commands.

 The cfg_sbref_en setting has no effect when l_ref_req/_ps0/_ps1 or l_sbref_req/_ps0/_ps1 are used to manually generate refreshes.

                }
            }
        }
        register CFG_RREFD @0x27c {
            bytes 4;
            field reserved @'h5 {
                bits 27;
            }
            field cfg_rrefd @'h0 {
                bits 5;
                access rw;
                hard_reset 'h8;
                doc {
                    This field defines the minimum number of memory clocks between single-/per-bank refresh commands.


                }
            }
        }
        register CFG_RFCSB @0x280 {
            bytes 4;
            field reserved @'h8 {
                bits 24;
            }
            field cfg_rfcsb @'h0 {
                bits 8;
                access rw;
                hard_reset 'h78;
                doc {
                    Minimum number of memory clocks between a single bank refresh command to a bank and a subsequent activate command to the same bank. Also used as the minimum number of memory clocks between the last single bank refresh command of a complete bank set to the subsequent single bank refresh command for the next bank set.

                }
            }
        }
        register CFG_LOOKAHEAD_SBREF @0x294 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field cfg_lookahead_sbref @'h0 {
                access rw;
                hard_reset 'h1;
                doc {
                    Look-ahead single-bank refresh enable. When enabled, the controller will look ahead into the command queue and analyze the queued requests and perform single-bank refresh operations as soon as possible in order to maximize bandwidth efficiency. It is recommended that this feature be disabled by hard connection of the port to '0' if the targeting the controller to FPGA running high internal timing frequencies.
 
 0 - disable
 
 1 - enable

                }
            }
        }
        register CFG_ADVANCE_ACTIVATE_READY @0x298 {
            bytes 4;
            field reserved @'h4 {
                bits 28;
            }
            field cfg_advance_activate_ready @'h0 {
                bits 4;
                access rw;
                hard_reset 'ha;
                doc {
                    Number of DFI clocks to advance the assertion of the l_activate_ready. A value of 0 will cause the assertion of the l_activate_ready to occur on the clock cycle that the controller determines that a bank can be activated. Increasing values of cfg_advance_activate_ready will cause l_activate_ready signals to assert earlier. Deassertion of l_activate_ready will always occur 1 clocks after a request is placed into the queue for that bank, regardless of the cfg_advance_activate_ready setting.

                }
            }
        }
        register CFG_RCD_RD @0x29c {
            bytes 4;
            field reserved @'h7 {
                bits 25;
            }
            field cfg_rcd_rd @'h0 {
                bits 7;
                access rw;
                hard_reset 'h10;
                doc {
                    SDRAM active to read delay (tRCDRD), specified in memory clocks.

                }
            }
        }
        register CFG_RCD_WR @0x2a0 {
            bytes 4;
            field reserved @'h6 {
                bits 26;
            }
            field cfg_rcd_wr @'h0 {
                bits 6;
                access rw;
                hard_reset 'he;
                doc {
                    SDRAM active to write delay (tRCDWR), specified in memory clocks.

                }
            }
        }
    }
    block MC_BASE2 @0x4000 {
        bytes 4;
        register CTRLR_SOFT_RESET_N @0x0 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field ctrlr_soft_reset_n @'h0 {
                access rw;
                hard_reset 'h0;
                doc {
                    Memory controller soft reset. Controller is in reset when this is set to 0.
 
                }
            }
        }
        register CFG_LOOKAHEAD_PCH @0x8 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field cfg_lookahead_pch @'h0 {
                access rw;
                hard_reset 'h1;
                doc {
                    Look-ahead precharge enable. When enabled the controller will look ahead into the command queue and perform precharge and auto-precharge operations as early as possible in order to maximize command bus efficiency and reduce latency. It is recommended that this feature be disabled by hard connection of the port to '0' if the targeting the controller to FPGA running high internal timing frequencies.
 
 0 - disable
 
 1 - enable

                }
            }
        }
        register CFG_LOOKAHEAD_ACT @0xc {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field cfg_lookahead_act @'h0 {
                access rw;
                hard_reset 'h1;
                doc {
                    Look-ahead activate enable. When enabled, the controller will look ahead into the command queue and analyze the queued requests and perform activate operations as soon as possible in order to maximize bandwidth efficiency. It is recommended that this feature be disabled by hard connection of the port to '0' if the targeting the controller to FPGA running high internal timing frequencies.
 
 0 - disable
 
 1 - enable

                }
            }
        }
        register INIT_AUTOINIT_DISABLE @0x10 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field init_autoinit_disable @'h0 {
                access rw;
                hard_reset 'h0;
                doc {
                    When set to '1', prevents the controller from generating the memory device initialization sequence. The user can then manually generate the initialization sequence using the remaining init_* controls. After the user has completed the initialization sequence, this signal must be set to '0'. This enables the controller to proceed to training and/or normal operation.

                }
            }
        }
        register INIT_FORCE_RESET @0x14 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field init_force_reset @'h0 {
                access rw;
                hard_reset 'h0;
                doc {
                    Forces assertion of reset control signal (sd_reset_n) going to SDRAM.

                }
            }
        }
        register INIT_DISABLE_CKE @0x1c {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field init_disable_cke @'h0 {
                access rw;
                hard_reset 'h0;
                doc {
                    Forces de-assertion of clock enable signal going to SDRAM.

                }
            }
        }
        register INIT_CS @0x20 {
            bytes 4;
            field reserved @'h8 {
                bits 24;
            }
            field init_cs @'h0 {
                bits 8;
                access rw;
                hard_reset 'h0;
                doc {
                    Rank selection for mode register programming requests (using init_mr*), precharge-all requests (using init_precharge_all), refresh (using init_refresh), and ZQ calibration requests (using init_zq_cal_req)

                }
            }
        }
        register INIT_PRECHARGE_ALL @0x24 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field init_precharge_all @'h0 {
                access rw;
                hard_reset 'h0;
                doc {
                    Issue Precharge-all command to memory devices on the ranks selected by init_cs.

                }
            }
        }
        register INIT_REFRESH @0x28 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field init_refresh @'h0 {
                access rw;
                hard_reset 'h0;
                doc {
                    Issue Refresh command to memory devices on the ranks selected by init_cs.
 
 It is illegal to assert init_refresh when cfg_auto_ref_en is asserted and init_autoinit_disable is deasserted.

                }
            }
        }
        register INIT_ACK @0x30 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field init_ack @'h0 {
                access rc;
                volatile 1
                hard_reset 'h0;
                doc {
                    Acknowledge for init_refresh, init_precharge_all, init_mr_w_req, init_zq_cal_req, init_zq_cal_start (LPDDR4) and init_nop. Cleared on read.

                }
            }
        }
        register CFG_BL @0x34 {
            bytes 4;
            field reserved @'h2 {
                bits 30;
            }
            field cfg_bl @'h0 {
                bits 2;
                access rw;
                hard_reset 'h1;
                doc {
                    SDRAM maximum burst length (encoded). 
 
 For "full-rate" configurations of the controller operating in DDR2, LPDDR2, LPDDR3 and HBM modes, values are decoded as follows:
 
 cfg_bl = 0x0 - 1 local side transfers / burst (2 DDR transfers)

 cfg_bl = 0x1 - 2 local side transfers / burst (4 DDR transfers)

 cfg_bl = 0x2 - 4 local side transfers / burst (8 DDR transfers)

 cfg_bl = 0x3 - 8 local side transfers / burst (16 DDR transfers)
 
 For "half-rate" configurations of the controller operating in DDR2, LPDDR2, LPDDR3 and HBM modes, values are decoded as follows:
 
 cfg_bl = 0x0 - Invalid

 cfg_bl = 0x1 - 1 local side transfer / burst (4 DDR transfers) 

 cfg_bl = 0x2 - 2 local side transfers / burst (8 DDR transfers)

 cfg_bl = 0x3 - 4 local side transfers / burst (16 DDR transfers)

 For "quarter-rate" configurations of the controller operating in DDR2, LPDDR2, and LPDDR3, values are decoded as follows:
 
 cfg_bl = 0x0 - Invalid

 cfg_bl = 0x1 - Invalid 

 cfg_bl = 0x2 - 2 local side transfers / burst (8 DDR transfers)

 cfg_bl = 0x3 - 4 local side transfers / burst (16 DDR transfers)

For LPDDR2 memory types, only settings of 0x1 and 0x2 are allowed.
For DDR2 memory type, only settings of 0x1 and 0x2 are allowed.
For LPDDR3 memory type, only setting of 0x2 is allowed.
For HBM memory type, only setting of 0x1 is allowed when operating in the half-rate configuration or when using an HBM Pseudo channel device. Settings of 0x0 and 0x1 are allowed when operating at full-rate with an HBM legacy device.

                }
            }
        }
        register CTRLR_INIT @0x38 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field ctrlr_init @'h0 {
                access rw;
                hard_reset 'h0;
                doc {
                    Causes the SDRAM Controller Core to re-issue the initialization sequence to SDRAM devices. The initialization will begin when a 0-1 transition is detected on this signal.
 
 Note: The SDRAM Controller Core will always issue the initialization sequence (including the startup delay) after reset regardless of the 'ctrlr_init' state. This signal can be tied low if run-time re-initialization is not required.

                }
            }
        }
        register CTRLR_INIT_DONE @0x3c {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field ctrlr_init_done @'h0 {
                access ro;
                volatile 1
                hard_reset 'h0;
                doc {
                    Deasserted when in reset or after ctrlr_init is asserted, then asserts when initialization sequence has completed.  If manual initialization is performed (init_autoinit_disable asserted at startup), this signal will not assert until init_autoinit_disable is deasserted by the user, indicating that the manual initialization sequence has completed.

                }
            }
        }
        register CFG_AUTO_REF_EN @0x40 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field cfg_auto_ref_en @'h0 {
                access rw;
                hard_reset 'h1;
                doc {
                    Enables controller initiated refresh cycles at a periodic rate determined by 'cfg_ref_per'. When this is set to '0', the user logic must take control of refresh by using special addressing techniques or by using the 'l_ref_req' input to manually generate refresh cycles.  Controller will postpone a refresh if the memory bus is busy at the end of a 'cfg_ref_per' and will initiate the refresh when the memory bus is available.  Up to 8 refresh requests can be postponed.  If the 'cfg_auto_ref_en' is disabled, any postponed refresh requests will be cleared.

                }
            }
        }
        register CFG_RAS @0x44 {
            bytes 4;
            field reserved @'h7 {
                bits 25;
            }
            field cfg_ras @'h0 {
                bits 7;
                access rw;
                hard_reset 'h1d;
                doc {
                    SDRAM active to precharge (tRAS), specified in memory clocks.

                }
            }
        }
        register CFG_RP @0x50 {
            bytes 4;
            field reserved @'h6 {
                bits 26;
            }
            field cfg_rp @'h0 {
                bits 6;
                access rw;
                hard_reset 'h10;
                doc {
                    SDRAM precharge command period (tRP), specified in memory clocks. 'cfg_rp' must be greater than or equal to 'cfg_rrd'.

                }
            }
        }
        register CFG_RC @0x54 {
            bytes 4;
            field reserved @'h8 {
                bits 24;
            }
            field cfg_rc @'h0 {
                bits 8;
                access rw;
                hard_reset 'h2d;
                doc {
                    SDRAM active to active / refresh command period (tRC), specified in memory clocks.

                }
            }
        }
        register CFG_FAW @0x58 {
            bytes 4;
            field reserved @'h9 {
                bits 23;
            }
            field cfg_faw @'h0 {
                bits 9;
                access rw;
                hard_reset 'h10;
                doc {
                    Four bank activate period (tFAW), specified in memory clocks

                }
            }
        }
        register CFG_RFC @0x5c {
            bytes 4;
            field reserved @'ha {
                bits 22;
            }
            field cfg_rfc @'h0 {
                bits 10;
                access rw;
                hard_reset 'h15e;
                doc {
                    SDRAM refresh to active / refresh command period (tRFC) specified in memory clocks.

                }
            }
        }
        register CFG_RTP @0x60 {
            bytes 4;
            field reserved @'h5 {
                bits 27;
            }
            field cfg_rtp @'h0 {
                bits 5;
                access rw;
                hard_reset 'h5;
                doc {
                    SDRAM read to precharge delay (tRTP), specified in memory clocks

                }
            }
        }
        register CFG_WR @0x64 {
            bytes 4;
            field reserved @'h6 {
                bits 26;
            }
            field cfg_wr @'h0 {
                bits 6;
                access rw;
                hard_reset 'h10;
                doc {
                    SDRAM write recovery time (tWR), specified in memory clocks. If the calculated value is not available then the next higher value should be chosen.

                }
            }
        }
        register CFG_XP @0x74 {
            bytes 4;
            field reserved @'h5 {
                bits 27;
            }
            field cfg_xp @'h0 {
                bits 5;
                access rw;
                hard_reset 'h8;
                doc {
                    SDRAM exit power-down mode to first valid command (tXP), specified in memory clocks.

                }
            }
        }
        register CFG_READ_TO_WRITE @0x88 {
            bytes 4;
            field reserved @'h4 {
                bits 28;
            }
            field cfg_read_to_write @'h0 {
                bits 4;
                access rw;
                hard_reset 'h4;
                doc {
                    Delay between the end of a read DQS postamble to the start of a write preamble, specified in memory clocks. The controller will delay issuing any write command immediately following a read command to achieve the turnaround time specified by this port.
 
 If 2 clock write preamble is being used, this value is specified relative to the middle of the 2 clock preamble.

                }
            }
        }
        register CFG_MIN_READ_IDLE @0xa8 {
            bytes 4;
            field reserved @'h3 {
                bits 29;
            }
            field cfg_min_read_idle @'h0 {
                bits 3;
                access rw;
                hard_reset 'h0;
                doc {
                    Minimum number of memory clocks of idle time on the bus between non-consecutive read commands. If any two reads are not back-to-back, this is the minimum idle time (in memory clocks) on the data bus between the reads. Values of 0 and 1 cause no minimum bus idle time between non-consecutive reads to be enforced. There is no difference in behavior between the 0 and 1 settings. This setting is useful for interfacing with physical interfaces which require bus idle time to reset in between reads.
                }
            }
        }
        register CFG_DS @0xb4 {
            bytes 4;
            field reserved @'h4 {
                bits 28;
            }
            field cfg_ds @'h0 {
                bits 4;
                access rw;
                hard_reset 'h0;
                doc {
                    Output driver strength setting programmed into "Output Driver Impedance Control", "Pull-down Drive Strength" or "Driver Strength" field of mode register during initialization sequence.  Refer to SDRAM datasheet for mapping to impedance values. Bits 2 and 3 are ignored for DDR4 and GDDR6 devices.  Bit 3 ignored for LPDDR4 devices.

                }
            }
        }
        register CFG_REF_PER @0xcc {
            bytes 4;
            field reserved @'h10 {
                bits 16;
            }
            field cfg_ref_per @'h0 {
                bits 16;
                access rw;
                hard_reset 'hf3b;
                doc {
                    Period between refresh commands issued by the controller, specified in memory clocks.  This value is 
 calculated as:
 
     cfg_ref_per = required refresh time interval / tCK
 

 If cfg_only_srank_cmds is set to 1 and cfg_quad_rank is set to 0, then the internal refresh 
 interval calculated by the controller will be cfg_ref_per divided by the number of ranks in 
 the system (cfg_num_ranks) since each refresh event will only be refreshing one rank.  In 
 this case the internal refresh interval is calculated as:

     refresh interval = cfg_ref_per / cfg_num_ranks

 With cfg_only_srank_cmds set to 1 and cfg_quad_rank set to 0, the controller supports 
 cfg_num_ranks settings of 1, 2, 3, 4, 6, 8, or 16.


 If cfg_only_srank_cmds is set to 1 and cfg_quad_rank is set to 1, then the internal refresh 
 interval calculated by the controller will be cfg_ref_per divided by one-half the number of 
 ranks in the system (cfg_num_ranks) since each refresh event will refresh two ranks (due to 
 cfg_quad_rank). In this case the internal refresh interval is calculated as:

     refresh interval = cfg_ref_per / ( cfg_num_ranks / 2 )
 
 With cfg_only_srank_cmds set to 1 and cfg_quad_rank set to 1, the controller supports 
 cfg_num_ranks settings of 4, 8, or 16.


                }
            }
        }
        register CFG_STARTUP_DELAY @0xd0 {
            bytes 4;
            field reserved @'h13 {
                bits 13;
            }
            field cfg_startup_delay @'h0 {
                bits 19;
                access rw;
                hard_reset 'h30d40;
                doc {
                    Delay after a reset event that the controller waits before initializing the SDRAM, specified in memory clocks. The NWL controller supports 4 initialization modes:
(1) Phy does all of the DRAM initialization (cfg_startup_delay is a don't care and cfg_ctrlr_init_disable is set to 1) and the NWL controller just waits for dfi_init_complete/dfi_training_complete to be asserted before beginning normal operation (generating refresh requests, etc.)
(2) Software does all of the DRAM  initialization (cfg_startup delay is a don't care and init_autoinit_disable is set to 1) and the NWL controller just waits for dfi_init_complete/dfi_training_complete to be asserted before beginning normal operation (generating refresh requests, etc.)
(3) NWL controller does all of the DRAM  initialization (cfg_startup_delay != 0 and phy/software initialization modes are not defined) and then waits for dfi_init_complete/dfi_training_complete to be asserted before beginning normal operation (generating refresh requests, etc.)
(4) The phy does all of the early CKE/memory reset initialization of the memory (cfg_startup_delay = 0 and phy/software initialization modes are not defined) and the NWL controller waits for dfi_init_complete/dfi_training_complete to be asserted before sequencing out the final mode registers settings and  beginning normal operation (generating refresh requests, etc.)

                }
            }
        }
        register CFG_MEM_ROWBITS @0xd8 {
            bytes 4;
            field reserved @'h5 {
                bits 27;
            }
            field cfg_mem_rowbits @'h0 {
                bits 5;
                access rw;
                hard_reset 'he;
                doc {
                    Number of bits in the row address.

                }
            }
        }
        register CFG_MEM_BANKBITS @0xdc {
            bytes 4;
            field reserved @'h3 {
                bits 29;
            }
            field cfg_mem_bankbits @'h0 {
                bits 3;
                access rw;
                hard_reset 'h5;
                doc {
                    Number of bits in the bank address (including DDR4/HBM bank group bits). For HBM pseudo channel memory, the pseudo channel select bit (BA4 in the JEDEC specification) does not count as a bank bit. If using an 8HI stack, the SID address bit counts as another bank group bit. Thus when using an HBM 8HI stack the cfg_mem_bankbits should be set to 5 (= 4 + 1) . 

                }
            }
        }
        register CFG_MOD @0x188 {
            bytes 4;
            field reserved @'h5 {
                bits 27;
            }
            field cfg_mod @'h0 {
                bits 5;
                access rw;
                hard_reset 'hf;
                doc {
                    SDRAM Mode Register Set command to any command (tMOD), specified in memory clocks. Min=24 for DDR4, 15 for HBM

                }
            }
        }
        register CFG_XS @0x18c {
            bytes 4;
            field reserved @'ha {
                bits 22;
            }
            field cfg_xs @'h0 {
                bits 10;
                access rw;
                hard_reset 'h168;
                doc {
                    SDRAM exit self-refresh to non-DLL command (tXS), specified in memory clocks.

                }
            }
        }
        register CFG_XPR @0x194 {
            bytes 4;
            field reserved @'ha {
                bits 22;
            }
            field cfg_xpr @'h0 {
                bits 10;
                access rw;
                hard_reset 'h168;
                doc {
                    Delay from CKE high to valid command, after exiting reset (tXPR). Specified in memory clocks.

                }
            }
        }
        register INIT_MR_W_REQ @0x1f0 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field init_mr_w_req @'h0 {
                access rw;
                hard_reset 'h0;
                doc {
                    Mode register write request. Initiates a mode register program to the mode register specified by init_mr_addr and rank(s) specified by init_cs. Assertion of init_ack signals the completion of the operation. All banks must be closed prior to making this request. This may be done using the init_precharge register. 

                }
            }
        }
        register INIT_MR_ADDR @0x1f4 {
            bytes 4;
            field reserved @'h8 {
                bits 24;
            }
            field init_mr_addr @'h0 {
                bits 8;
                access rw;
                hard_reset 'h0;
                doc {
                    Mode register address to be written to when init_mr_w_req is asserted.

                }
            }
        }
        register INIT_MR_WR_DATA @0x1f8 {
            bytes 4;
            field reserved @'h12 {
                bits 14;
            }
            field init_mr_wr_data @'h0 {
                bits 18;
                access rw;
                hard_reset 'h0;
                doc {
                    Value to be programmed into mode register.

 For HBM only bits 7 to 0 are used (OP7 = init_mr_wrdata[7],... OP0 = init_mr_wrdata[0]).

                }
            }
        }
        register INIT_MR_WR_MASK @0x1fc {
            bytes 4;
            field reserved @'h12 {
                bits 14;
            }
            field init_mr_wr_mask @'h0 {
                bits 18;
                access rw;
                hard_reset 'h0;
                doc {
                    Mask for mode register writes. Mode register bits corresponding to bits asserted in this bus will be sourced from settings on cfg_* inputs to the controller rather than the init_mr_wr_data bus.

                }
            }
        }
        register CFG_WL @0x224 {
            bytes 4;
            field reserved @'h6 {
                bits 26;
            }
            field cfg_wl @'h0 {
                bits 6;
                access rw;
                hard_reset 'h7;
                doc {
                    Write latency, specified in memory clocks.

 Valid values for HBM are 6 through 8.

 Valid values for LPDDR4 are 4 through 34.

 Valid values for GDDR6 are 5 through 8.

                }
            }
        }
        register CFG_RL @0x228 {
            bytes 4;
            field reserved @'h6 {
                bits 26;
            }
            field cfg_rl @'h0 {
                bits 6;
                access rw;
                hard_reset 'h16;
                doc {
                    Read latency, specified in memory clocks.

                }
            }
        }
        register CFG_CAL_READ_PERIOD @0x22c {
            bytes 4;
            field reserved @'h16 {
                bits 10;
            }
            field cfg_cal_read_period @'h0 {
                bits 22;
                access rw;
                hard_reset 'h0;
                doc {
                    Period between calibration reads, specified in system clocks. Set to 0 to disable periodic calibration reads.  [This port only included in PHY configurations which require periodic calibration reads.]

                }
            }
        }
        register CFG_NUM_CAL_READS @0x230 {
            bytes 4;
            field reserved @'h2 {
                bits 30;
            }
            field cfg_num_cal_reads @'h0 {
                bits 2;
                access rw;
                hard_reset 'h0;
                doc {
                    Number of calibration reads that are issued each time cfg_cal_read_period timer expires.
 
 [This port only included in PHY configurations which require periodic calibration reads.]

                }
            }
        }
        register INIT_SELF_REFRESH @0x234 {
            bytes 4;
            field reserved @'h8 {
                bits 24;
            }
            field init_self_refresh @'h0 {
                bits 8;
                access rw;
                hard_reset 'h0;
                doc {
                    Self-refresh control. Causes the controller to put the selected SDRAM rank (chip select) into self-refresh mode at the next refresh event. Each bit in init_self_refresh corresponds to the selected rank; asserting init_self_refresh[0] puts the devices connected to cs_n[0] into self refresh, init_self_refresh[1] for cs_n[1] and so on.
 
 This bus performs the same function as l_self_refresh, however this bus is first level-synchronized to the memory controller clock domain within the controller. This allows it to be controlled from a different clock domain, as is typically the case when driven from a control / status register (CSR) module.

                }
            }
        }
        register INIT_SELF_REFRESH_STATUS @0x238 {
            bytes 4;
            field reserved @'h8 {
                bits 24;
            }
            field init_self_refresh_status @'h0 {
                bits 8;
                access ro;
                volatile 1
                hard_reset 'h0;
                doc {
                    Indicates which ranks are in self-refresh

                }
            }
        }
        register INIT_POWER_DOWN @0x23c {
            bytes 4;
            field reserved @'h8 {
                bits 24;
            }
            field init_power_down @'h0 {
                bits 8;
                access rw;
                hard_reset 'h0;
                doc {
                    Power down control. Causes the controller to put the selected SDRAM rank (chip select) into power down mode. The core will automatically continue to refresh all devices so that data is retained.
 
 This bus performs the same function as l_power_down, however this bus is first level-synchronized to the memory controller clock domain within the controller. This allows it to be controlled from a different clock domain, as is typically the case when driven from a control / status register (CSR) module.

                }
            }
        }
        register INIT_POWER_DOWN_STATUS @0x240 {
            bytes 4;
            field reserved @'h8 {
                bits 24;
            }
            field init_power_down_status @'h0 {
                bits 8;
                access ro;
                volatile 1
                hard_reset 'h0;
                doc {
                    Indicates which ranks are in power-down

                }
            }
        }
        register INIT_FORCE_WRITE @0x244 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field init_force_write @'h0 {
                access rw;
                hard_reset 'h0;
                doc {
                    Forces assertion of 'dfi_wrdata_en' and 'dfi_odt' which will cause the PHY to drive its DQ, DQS and ODT outputs, regardless of whether a write command is issued or not. This feature can be used for software-driven write leveling as well as hardware debug of the write interface.
 
 When init_force_write is asserted and a regular write is not being driven by the controller, the data pattern is specified by 'init_force_write_data', and the rank driven to 'dfi_wrdata_cs' is specified by 'init_force_write_cs'. Whenever a regular write is being driven by the controller, the data pattern and rank come from the normal controller path, regardless of the state of 'init_force_write'.

                }
            }
        }
        register INIT_FORCE_WRITE_CS @0x248 {
            bytes 4;
            field reserved @'h8 {
                bits 24;
            }
            field init_force_write_cs @'h0 {
                bits 8;
                access rw;
                hard_reset 'h0;
                doc {
                    Rank passed to PHY on dfi_wrdata_cs when init_force_write is asserted and a regular write is not being driven.

                }
            }
        }
        register CFG_CTRLR_INIT_DISABLE @0x24c {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field cfg_ctrlr_init_disable @'h0 {
                access rw;
                hard_reset 'h0;
                doc {
                    Controller initialization is bypassed when asserted, allowing PHY to perform initialization instead.

                }
            }
        }
        register CTRLR_READY @0x250 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field ctrlr_ready @'h0 {
                access ro;
                volatile 1
                hard_reset 'h0;
                doc {
                    Deasserted when in reset or after ctrlr_init is asserted, then asserts after initialization sequence and training sequences (if required) have completed

                }
            }
        }
        register INIT_MEMORY_RESET_MASK @0x268 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field init_memory_reset_mask @'h0 {
                access rw;
                hard_reset 'h0;
                doc {
                    When set, masks the reset output of the controller (dfi_reset_n_pN) so that it does not assert when the controller is in reset. This function can be useful in situations where the memory controller needs to be reset while holding the memory devices in the self-refresh state.
 
 This signal is connected to the reset_n pin of level synchronization flip-flops inside the memory controller. This guarantees synchronous assertion of the internal masking logic when the init_memory_reset_mask signal is not synchronized to the memory controller clock. However, this method does not guarantee synchronous de-assertion of the internal masking logic when init_memory_reset_mask transitions from 1 to 0. Therefore, 1 to 0 transitions should only happen while the memory controller is in reset (reset_n = 0).

                }
            }
        }
        register CFG_CTRLUPD_TRIG @0x2c0 {
            bytes 4;
            field reserved @'h3 {
                bits 29;
            }
            field cfg_ctrlupd_trig @'h0 {
                bits 3;
                access rw;
                hard_reset 'h0;
                doc {
                    Specifies the trigger for the controller initiated update signal ('dfi_ctrlupd_req').

 0 - Disable

 1 - Any all-bank refresh event triggers controller initiated update request

 2 - Any ZQ-calibration event triggers controller initiated update request (for memory technologies that support it)

                }
            }
        }
        register CFG_CTRLUPD_START_DELAY @0x2c4 {
            bytes 4;
            field reserved @'ha {
                bits 22;
            }
            field cfg_ctrlupd_start_delay @'h0 {
                bits 10;
                access rw;
                hard_reset 'h16;
                doc {
                    Delay from the DFI MC-initiated update trigger event command (as specified by 'cfg_ctrlupd_trig') to when the controller asserts 'dfi_ctrlupd_req'. This delay is specified in DFI clocks and is measured at the DFI interface to the PHY and can take on values of 0 (not recommended) to 1023. When DDR4 Command-Address-Latency (CAL) mode is used, the delay is from the assertion of the command at the DFI interface (which occurs sometime after the associated chip-select assertion in CAL mode). Note that this register defaults to the minimum recommended value of 5; however it is possible that some phys that support dfi_ctrlupd_req will require a larger cfg_ctrlupd_start_delay value to guarantee that a previous read in progress has completed before the NWL controller asserts dfi_ctrlupd_req as determined by this value and the cfg_ctrlupd_trig CSR. 

                }
            }
        }
        register CFG_DFI_T_CTRLUPD_MAX @0x2c8 {
            bytes 4;
            field reserved @'ha {
                bits 22;
            }
            field cfg_dfi_t_ctrlupd_max @'h0 {
                bits 10;
                access rw;
                hard_reset 'hc8;
                doc {
                    Duration of 'dfi_ctrlupd_req' assertion.

0 - 'dfi_ctrlupd_req' will only de-assert after 'dfi_ctrlupd_ack' is asserted and then deasserted.

1-1023 - Duration of 'dfi_ctrlupd_req' assertion, specified in dfi clocks. 'dfi_ctrlupd_req' will deassert if 'dfi_ctrlupd_ack' asserts and deasserts before this time has elapsed. Otherwise 'dfi_ctrlupd_req' will deassert immediately after this time has elapsed.

                }
            }
        }
        register CFG_PHYUPD_ACK_DELAY @0x2fc {
            bytes 4;
            field reserved @'ha {
                bits 22;
            }
            field cfg_phyupd_ack_delay @'h0 {
                bits 10;
                access rw;
                hard_reset 'h16;
                doc {
                    Delay in DFI clocks before the dfi_phyupd_ack signal is asserted.  The delay is measured from the time the DFI bus is idle after receiving a dfi_phyupd_req, providing additional margin between the request and acknowledge.

                }
            }
        }
        register CFG_DRAM_CLK_DISABLE_IN_SELF_REFRESH @0x30c {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field cfg_dram_clk_disable_in_self_refresh @'h0 {
                access rw;
                hard_reset 'h0;
                doc {
                    When set, all clock outputs to DRAM are disabled after all ranks are put into self-refresh. Clocks are automatically restarted before ranks exit self-refresh. Clocks are controlled using the dfi_dram_clk_disable port going to the PHY.  It is expected that the DB in an LRDIMM application will need to be retrained after the clocks have been stopped.  Therefore this feature is not used in an LRDIMM configuration.  The init_dfi_dram_clk_disable port may be used to stop the DRAM clocks for an LRDIMM.

                }
            }
        }
        register CFG_CKSRE @0x310 {
            bytes 4;
            field reserved @'h5 {
                bits 27;
            }
            field cfg_cksre @'h0 {
                bits 5;
                access rw;
                hard_reset 'ha;
                doc {
                    Valid DRAM clock requirement after self-refresh entry (tCKSRE), specified in memory clocks. For DDR4 the controller automatically includes parity latency so that tCKSRE_PAR is satisfied as well.

                }
            }
        }
        register CFG_CKSRX @0x314 {
            bytes 4;
            field reserved @'h5 {
                bits 27;
            }
            field cfg_cksrx @'h0 {
                bits 5;
                access rw;
                hard_reset 'ha;
                doc {
                    Valid DRAM clock requirement before self-refresh exit (tCKSRX), specified in memory clocks.

                }
            }
        }
        register CFG_DFI_T_CTRL_DELAY @0x31c {
            bytes 4;
            field reserved @'h8 {
                bits 24;
            }
            field cfg_dfi_t_ctrl_delay @'h0 {
                bits 8;
                access rw;
                hard_reset 'h0;
                doc {
                    Number of memory clocks required for the DFI control signals presented to the PHY to reach the DRAM interface of the PHY. This value is used to delay the disable of the clock going to memory via dfi_dram_clk_disable, after self-refresh entry when cfg_dram_clk_disable_in_self_refresh is set to 1.

                }
            }
        }
        register CFG_DFI_T_DRAM_CLK_ENABLE @0x320 {
            bytes 4;
            field reserved @'h8 {
                bits 24;
            }
            field cfg_dfi_t_dram_clk_enable @'h0 {
                bits 8;
                access rw;
                hard_reset 'h0;
                doc {
                    Number of memory clock cycles from the deassertion of the dfi_dram_clk_disable signal until the first valid rising clock edge at the DRAM interface of the PHY.

                }
            }
        }
        register CFG_IDLE_TIME_TO_SELF_REFRESH @0x324 {
            bytes 4;
            field cfg_idle_time_to_self_refresh @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Duration from the last data transaction to when the controller automatically puts all ranks in self-refresh, specified in memory clocks.  A value of 0 disables the automatic self-refresh entry feature.

                }
            }
        }
        register CFG_IDLE_TIME_TO_POWER_DOWN @0x328 {
            bytes 4;
            field cfg_idle_time_to_power_down @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Duration from the last data transaction to when the controller automatically puts all ranks in power-down, specified in memory clocks.  A value of 0 disables the automatic power-down entry feature.

                }
            }
        }
        register CFG_BURST_RW_REFRESH_HOLDOFF @0x32c {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field cfg_burst_rw_refresh_holdoff @'h0 {
                access rw;
                hard_reset 'h0;
                doc {
                    When set, refresh request is held off until all writes or reads of current burst has been executed.  In this mode, refresh is demoted to priority level below that of writes and reads.

                }
            }
        }
        register INIT_REFRESH_COUNT @0x330 {
            bytes 4;
            field reserved @'h6 {
                bits 26;
            }
            field init_refresh_count @'h0 {
                bits 6;
                access ro;
                volatile 1
                hard_reset 'h0;
                doc {
                    Indicates the number of REFRESH commands that are in the automatic refresh queue when cfg_auto_ref_en = 1.  Values > 1 indicate that REFRESH commands are being postponed.

                }
            }
        }
        register CFG_BG_INTERLEAVE @0x380 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field cfg_bg_interleave @'h0 {
                access rw;
                hard_reset 'h1;
                doc {
                    Enables interleaving of bank-groups in back-to-back transactions to avoid tCCD_L delays in DRAM architectures with bank groups (DDR4, HBM and GDDR6). When set, the address is mapped such that the BG0 bit toggles on each successive read/write command as l_addr is sequentially increased. This setting has no effect when manual address mapping is used (cfg_manual_address_map = 1). 

 The Multi-burst core also uses this register to determine when to issue requests with the auto-precharge attribute. When this register is set and l_auto_pch is set for a request, the multiburst module sets the auto-precharge attribute with the last two requests in a multi-burst series so that both of the accessed banks are closed. When this register is clear and l_auto_pch is set, the multiburst module sets the auto-precharge attribute with only the last request since that is the only bank group that has been accessed.


                }
            }
        }
        register CFG_DBI_BYTE_DISABLE_SOURCE @0x384 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field cfg_dbi_byte_disable_source @'h0 {
                access rw;
                hard_reset 'h0;
                doc {
                    Selects either cfg_dbi_byte_disable or dfi_dbi_byte_disable as control source for DBI byte disable. The dfi_dbi_byte_disable bus is used by PHYs which communicate the mode 1 lane repair information to the controller across the DFI bus.

 0 - dfi_dbi_byte_disable
 1 - cfg_dbi_byte_disable

                }
            }
        }
        register CFG_DBI_BYTE_DISABLE @0x388 {
            bytes 4;
            field reserved @'h10 {
                bits 16;
            }
            field cfg_dbi_byte_disable @'h0 {
                bits 16;
                access rw;
                hard_reset 'h0;
                doc {
                    Selects which bytes to disable DBI. The ability for the controller to disable DBI on specific bytes may be required by PHYs for HBM mode 1 lane repair, where DBI pins are reassigned to replace other failing data pins. Some PHYs may not support mode 1 lane repair, or may automatically adjust DBI for byte lanes where DBI is inverted, in which case this programmability of the controller is not needed. 
    
    cfg_dbi_byte_disable[7:0] - pseudo channel 0
    cfg_dbi_byte_disable[15:8] - pseudo channel 1

                }
            }
        }
        register INIT_HBM_ROW_COL_PARITY_ERROR_GEN_REQ @0x38c {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field init_hbm_row_col_parity_error_gen_req @'h0 {
                access rw;
                hard_reset 'h0;
                doc {
                    Requests a parity error to be generated on the next command selected by the init_hbm_row_col_parity_error_gen_cmd register.  The parity error is generated by inverting the parity bit of the selected command.  Once the init_hbm_row_col_parity_error_gen_ack is asserted the init_hbm_row_col_parity_error_gen_req register must be cleared and re-asserted to generate another parity error.

                }
            }
        }
        register INIT_HBM_ROW_COL_PARITY_ERROR_GEN_CMD @0x398 {
            bytes 4;
            field reserved @'h4 {
                bits 28;
            }
            field init_hbm_row_col_parity_error_gen_cmd @'h0 {
                bits 4;
                access rw;
                hard_reset 'h0;
                doc {
                    Specifies the command for which the parity error will be generated once init_hbm_row_col_parity_error_gen_req is asserted.  The command encoding is as follows:

 0x0  - Reserved

 0x1  - ACT0      : parity error will be generated on the first clock of the activate command

 0x2  - ACT1      : parity error will be generated on the second clock of the activate command

 0x3  - PREA/PRE  : parity error will be generated on next precharge or precharge-all command

 0x4  - REF       : parity error will be generated on next refresh-all command

 0x5  - REFSB     : parity error will be generated on next single-bank refresh command

 0x6  - Reserved

 0x7  - RNOP      : parity error will be generated on next row no operation command

 0x8  - Reserved

 0x9  - Reserved

 0xa  - Reserved

 0xb  - MRS       : parity error will be generated on next mode register set command

 0xc  - WR/WRA    : parity error will be generated on next write or write with auto-precharge command

 0xd  - RD/RDA    : parity error will be generated on next read or read with auto-precharge command

 0xe  - Reserved

 0xf  - CNOP      : parity error will be generated on next column no operation command


                }
            }
        }
        register INIT_HBM_ROW_COL_PARITY_ERROR_GEN_ACK @0x3a4 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field init_hbm_row_col_parity_error_gen_ack @'h0 {
                access rc;
                volatile 1
                hard_reset 'h0;
                doc {
                    Asserted to acknowledge that the parity error requested by init_hbm_row_col_parity_error_gen_req has been issued.  Bit 0 indicates that the write data parity error generation is complete while bit 1 indicates that the read data parity error generation is complete.  

                }
            }
        }
        register INIT_HBM_DATA_PARITY_ERROR_GEN_REQ @0x3b0 {
            bytes 4;
            field reserved @'h2 {
                bits 30;
            }
            field init_hbm_data_parity_error_gen_req @'h0 {
                bits 2;
                access rw;
                hard_reset 'h0;
                doc {
                    Requests a data parity error pattern to be generated for the data transfer of the next burst read and/or write to the HBM memory device.  Setting bit 0 indicates that a write data parity error is requested while setting bit 1 indicates that a read data parity error is requested.  The sequence pattern of errors to generate is determined by the init_hbm_write_data_perr_gen_pattern and init_hbm_read_data_perr_gen_pattern registers. The parity error is generated by inverting the 0th data bit for the DWORD(s) of the transfer as selected by the init_hbm_data_parity_error_gen_sel register.  Once the init_hbm_data_parity_error_gen_ack is asserted the init_hbm_data_parity_error_gen_req register must be cleared and re-asserted to generate another data parity error.

                }
            }
        }
        register INIT_HBM_DATA_PARITY_ERROR_GEN_SEL @0x3c8 {
            bytes 4;
            field reserved @'h10 {
                bits 16;
            }
            field init_hbm_data_parity_error_gen_sel @'h0 {
                bits 16;
                access rw;
                hard_reset 'h0;
                doc {
                    Selects the DWORD(s) for the data parity error requested when init_hbm_data_parity_error_gen_req is asserted.  There are four data transfers per burst in HBM (BL4).  
 
 For HBM memory controllers with a single-controller (Options B & D) each 4-bit quanta of this register represents the parity error generation for the four DWORDs of the channel for the respective data transfer.  A 1'b1 in the selected bit will generate a data parity error on that DWORD for that transfer of the burst.

 [ 3: 0] : parity error generation for first data transfer

 [ 7: 4] : parity error generation for second data transfer

 [11: 8] : parity error generation for third data transfer

 [15:12] : parity error generation for fourth data transfer

 For HBM memory controllers with dual-controllers (Option E) each 2-bit quanta of this register represents the parity error generation for the two DWORDs of the pseudo channel for the respective data transfer.  A 1'b1 in the selected bit will generate a data parity error on that DWORD for that transfer of the burst.

 [ 1: 0] : parity error generation for first data transfer

 [ 3: 2] : parity error generation for second data transfer

 [ 5: 4] : parity error generation for third data transfer

 [ 7: 6] : parity error generation for fourth data transfer

 [15: 8] : reserved


                }
            }
        }
        register INIT_HBM_DATA_PARITY_ERROR_GEN_ACK @0x3d4 {
            bytes 4;
            field reserved @'h2 {
                bits 30;
            }
            field init_hbm_data_parity_error_gen_ack @'h0 {
                bits 2;
                access rc;
                volatile 1
                hard_reset 'h0;
                doc {
                    Asserted to acknowledge that the pattern of parity error(s) requested by init_hbm_data_parity_error_gen_req have been issued.

                }
            }
        }
        register INIT_HBM_WRITE_DATA_PERR_GEN_PATTERN @0x3e0 {
            bytes 4;
            field init_hbm_write_data_perr_gen_pattern @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Sequence pattern of parity errors to generate during following write transfers.  Each asserted bit position set to 1 will cause a parity error, while those set to 0 will not create an error in the sequence of transfers.

                }
            }
        }
        register INIT_HBM_READ_DATA_PERR_GEN_PATTERN @0x3ec {
            bytes 4;
            field init_hbm_read_data_perr_gen_pattern @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Sequence pattern of parity errors to generate during following read transfers.  Each asserted bit position set to 1 will cause a parity error, while those set to 0 will not create an error in the sequence of transfers.

                }
            }
        }
        register CFG_REFRESH_DURING_PHY_TRAINING @0x3f8 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field cfg_refresh_during_phy_training @'h0 {
                access rw;
                hard_reset 'h0;
                doc {
                    Use in conjunction with cfg_auto_ref_en to enable controller-initiated refresh cycles during PHY training. When this is set to '0', the controller will not issue refresh while PHY training is active.

                }
            }
        }
    }
    block MEM_TEST @0x4400 {
        bytes 4;
        register MT_EN @0x0 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field mt_en @'h0 {
                access rw;
                hard_reset 'h0;
                doc {
                    Rising edge on 'mt_en' or 'mt_enable_single" starts a test.

                }
            }
        }
        register MT_EN_SINGLE @0x4 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field mt_en_single @'h0 {
                access rw;
                hard_reset 'h0;
                doc {
                    Enables single memory test. The memory test will only start after a low to high transition of this signal. The memory test will not repeat if 'mt_en_single' remains asserted at the end of the memory test.

                }
            }
        }
        register MT_STOP_ON_ERROR @0x8 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field mt_stop_on_error @'h0 {
                access rw;
                hard_reset 'h0;
                doc {
                    When mt_en is held asserted so that the memory test repeats multiple times, setting this bit will prevent the test from repeating again if an error was detected on the previous run. This is useful for debugging very infrequent errors which require many repetitions of the test before the error occurs. For example, once the error has occurred and the test has stopped, the test can be repeated with the 'mt_read_only' flag set, to help determine if the error occurred on a write or a read.

                }
            }
        }
        register MT_RD_ONLY @0xc {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field mt_rd_only @'h0 {
                access rw;
                hard_reset 'h0;
                doc {
                    Causes only reads to be performed when the memory test is enabled. Should not be set when 'mt_wr_only' is also set.

                }
            }
        }
        register MT_WR_ONLY @0x10 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field mt_wr_only @'h0 {
                access rw;
                hard_reset 'h0;
                doc {
                    Causes only writes to be performed when the memory test is enabled. Should not be set when 'mt_rd_only' is also set.

                }
            }
        }
        register MT_DATA_PATTERN @0x14 {
            bytes 4;
            field reserved @'h4 {
                bits 28;
            }
            field mt_data_pattern @'h0 {
                bits 4;
                access rw;
                hard_reset 'h0;
                doc {
                    Memory test data pattern selection:
 
 0x0 : Counting pattern
 
 0x1 : Walking 1's
 
 0x2 : Repeating Pseudo-random data (generated with LFSR). Repeats pattern sequence on each pass when test is run repetitively with 'mt_en' held high.
 
 0x3 : Non-Repeating Pseudo-random data (generated with LFSR). Pattern continues from where it left off on previous test when 'mt_en' is held high.
 
 0x4 : Alternating all 1's and all 0's
 
 0x5 : Alternating 5's and a's
 
 0x6 : User-specified pattern, specified with mt_user_data_pattern.  Pattern copied across all bytes of data bus on memory writes, and all bytes of expected data on memory reads.
 
 0x7 : Pseudo-random 16-bit data (generated with LFSR), copied across all words of data bus.
 
 0x8 : Pseudo-random 8-bit data (generated with LFSR), copied across all bytes of data bus.

                }
            }
        }
        register MT_ADDR_PATTERN @0x18 {
            bytes 4;
            field reserved @'h2 {
                bits 30;
            }
            field mt_addr_pattern @'h0 {
                bits 2;
                access rw;
                hard_reset 'h0;
                doc {
                    Memory test address pattern selection:
 
 0x0 : Counting pattern
 
 0x1 : LFSR
 
 0x2 : Arbitrary Pattern Generator
 
 0x3 : Reserved
 
 The LFSR address pattern is used only when the LFSR address pattern is selected and (mt_addr_bits - cfg_bl - 1) is greater than 2. Otherwise, counting address pattern is used, regardless of which address pattern is selected.

                }
            }
        }
        register MT_DATA_INVERT @0x1c {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field mt_data_invert @'h0 {
                access rw;
                hard_reset 'h0;
                doc {
                    Invert data pattern

                }
            }
        }
        register MT_ADDR_BITS @0x20 {
            bytes 4;
            field reserved @'h6 {
                bits 26;
            }
            field mt_addr_bits @'h0 {
                bits 6;
                access rw;
                hard_reset 'h8;
                doc {
                    Address range to test. Test will start at 'mt_start_addr' and continue to addresses 'mt_start_addr' + 2 ^ mt_addr_bits.
 
 Note: The minimum valid value is a function of memory burst length:
 
 1 - (memory burst length = 2)
 
 2 - (memory burst length = 4)
 
 3 - (memory burst length = 8)

                }
            }
        }
        register MT_ERROR_STS @0x24 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field mt_error_sts @'h0 {
                access rc;
                volatile 1
                hard_reset 'h0;
                doc {
                    Goes true when the memory test module detects a mismatch between expected data and the data read from the sdram. Cleared immediately after reading this csr.

                }
            }
        }
        register MT_DONE_ACK @0x28 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field mt_done_ack @'h0 {
                access rc;
                volatile 1
                hard_reset 'h0;
                doc {
                    Indicates completion of memory test through address range specified by 'mt_addr_bits'.  Signal is asserted when final test completes after mt_en has been cleared.

                }
            }
        }
        register MT_MAX_WD @0x2c {
            bytes 4;
            field reserved @'h6 {
                bits 26;
            }
            field mt_max_wd @'h0 {
                bits 6;
                access rw;
                hard_reset 'h0;
                doc {
                    Maximum address to be used in the Write Data RAM. After the maximum address is used then the next address will be 0. If 'mt_max_wd' is equal to 7 then locations 0 through 7 of the Write Data ram will be used during the test.

                }
            }
        }
        register MT_MAX_EX @0x30 {
            bytes 4;
            field reserved @'h6 {
                bits 26;
            }
            field mt_max_ex @'h0 {
                bits 6;
                access rw;
                hard_reset 'h0;
                doc {
                    Maximum address to be used in the Expect Data RAM. After the maximum address is used then the next address will be 0. If 'mt_max_ex' is equal to 11 then locations 0 through 11 of the Write Data ram will be used during the test.

                }
            }
        }
        register MT_MAX_AC @0x34 {
            bytes 4;
            field reserved @'h4 {
                bits 28;
            }
            field mt_max_ac @'h0 {
                bits 4;
                access rw;
                hard_reset 'h0;
                doc {
                    Maximum address to be used in the Address RAM. After the maximum address is used then the next address will be 0. If 'mt_max_ac' is equal to 5 then locations 0 through 5 of the address ram will be used during the test.

                }
            }
        }
        register MT_CYCLES @0x38 {
            bytes 4;
            field reserved @'h10 {
                bits 16;
            }
            field mt_cycles @'h0 {
                bits 16;
                access rw;
                hard_reset 'h0;
                doc {
                    The number of write cycles plus the number of read cycles to execute during the test.

                }
            }
        }
        register MT_ARB_MEM_ADDR @0x3c {
            bytes 4;
            field reserved @'h10 {
                bits 16;
            }
            field mt_arb_mem_addr @'h0 {
                bits 16;
                access rw;
                hard_reset 'h0;
                doc {
                    Value to load into the pointers of the Address RAM the Write Data RAM and the Expect Data RAM to prepare for reading and writing the rams. The maximum value depends on the size of the memories.

                }
            }
        }
        register MT_ARB_ACK @0x40 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field mt_arb_ack @'h0 {
                access rc;
                volatile 1
                hard_reset 'h0;
                doc {
                    Indicates read or write of an arbitrary pattern generator RAM in the Memory Test Core has been accepted.

                }
            }
        }
        register MT_WD_WDATA_0 @0x44 {
            bytes 4;
            field mt_wd_wdata_0 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Write data mask and data for the arbitrary pattern generator. Bit fields are organized as follows:
 
 [n+n/8-1:n] Write data mask
 
 [n-1:0] Write Data

                }
            }
        }
        register MT_WD_WDATA_1 @0x48 {
            bytes 4;
            field mt_wd_wdata_1 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Write data mask and data for the arbitrary pattern generator. Bit fields are organized as follows:
 
 [n+n/8-1:n] Write data mask
 
 [n-1:0] Write Data

                }
            }
        }
        register MT_WD_WDATA_2 @0x4c {
            bytes 4;
            field mt_wd_wdata_2 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Write data mask and data for the arbitrary pattern generator. Bit fields are organized as follows:
 
 [n+n/8-1:n] Write data mask
 
 [n-1:0] Write Data

                }
            }
        }
        register MT_WD_WDATA_3 @0x50 {
            bytes 4;
            field mt_wd_wdata_3 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Write data mask and data for the arbitrary pattern generator. Bit fields are organized as follows:
 
 [n+n/8-1:n] Write data mask
 
 [n-1:0] Write Data

                }
            }
        }
        register MT_WD_WDATA_4 @0x54 {
            bytes 4;
            field mt_wd_wdata_4 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Write data mask and data for the arbitrary pattern generator. Bit fields are organized as follows:
 
 [n+n/8-1:n] Write data mask
 
 [n-1:0] Write Data

                }
            }
        }
        register MT_WD_WDATA_5 @0x58 {
            bytes 4;
            field mt_wd_wdata_5 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Write data mask and data for the arbitrary pattern generator. Bit fields are organized as follows:
 
 [n+n/8-1:n] Write data mask
 
 [n-1:0] Write Data

                }
            }
        }
        register MT_WD_WDATA_6 @0x5c {
            bytes 4;
            field mt_wd_wdata_6 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Write data mask and data for the arbitrary pattern generator. Bit fields are organized as follows:
 
 [n+n/8-1:n] Write data mask
 
 [n-1:0] Write Data

                }
            }
        }
        register MT_WD_WDATA_7 @0x60 {
            bytes 4;
            field mt_wd_wdata_7 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Write data mask and data for the arbitrary pattern generator. Bit fields are organized as follows:
 
 [n+n/8-1:n] Write data mask
 
 [n-1:0] Write Data

                }
            }
        }
        register MT_WD_WDATA_8 @0x64 {
            bytes 4;
            field mt_wd_wdata_8 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Write data mask and data for the arbitrary pattern generator. Bit fields are organized as follows:
 
 [n+n/8-1:n] Write data mask
 
 [n-1:0] Write Data

                }
            }
        }
        register MT_WD_WDATA_9 @0x68 {
            bytes 4;
            field mt_wd_wdata_9 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Write data mask and data for the arbitrary pattern generator. Bit fields are organized as follows:
 
 [n+n/8-1:n] Write data mask
 
 [n-1:0] Write Data

                }
            }
        }
        register MT_WD_WDATA_10 @0x6c {
            bytes 4;
            field mt_wd_wdata_10 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Write data mask and data for the arbitrary pattern generator. Bit fields are organized as follows:
 
 [n+n/8-1:n] Write data mask
 
 [n-1:0] Write Data

                }
            }
        }
        register MT_WD_WDATA_11 @0x70 {
            bytes 4;
            field mt_wd_wdata_11 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Write data mask and data for the arbitrary pattern generator. Bit fields are organized as follows:
 
 [n+n/8-1:n] Write data mask
 
 [n-1:0] Write Data

                }
            }
        }
        register MT_WD_WDATA_12 @0x74 {
            bytes 4;
            field mt_wd_wdata_12 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Write data mask and data for the arbitrary pattern generator. Bit fields are organized as follows:
 
 [n+n/8-1:n] Write data mask
 
 [n-1:0] Write Data

                }
            }
        }
        register MT_WD_WDATA_13 @0x78 {
            bytes 4;
            field mt_wd_wdata_13 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Write data mask and data for the arbitrary pattern generator. Bit fields are organized as follows:
 
 [n+n/8-1:n] Write data mask
 
 [n-1:0] Write Data

                }
            }
        }
        register MT_WD_WDATA_14 @0x7c {
            bytes 4;
            field mt_wd_wdata_14 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Write data mask and data for the arbitrary pattern generator. Bit fields are organized as follows:
 
 [n+n/8-1:n] Write data mask
 
 [n-1:0] Write Data

                }
            }
        }
        register MT_WD_WDATA_15 @0x80 {
            bytes 4;
            field mt_wd_wdata_15 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Write data mask and data for the arbitrary pattern generator. Bit fields are organized as follows:
 
 [n+n/8-1:n] Write data mask
 
 [n-1:0] Write Data

                }
            }
        }
        register MT_WD_WDATA_16 @0x84 {
            bytes 4;
            field mt_wd_wdata_16 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Write data mask and data for the arbitrary pattern generator. Bit fields are organized as follows:
 
 [n+n/8-1:n] Write data mask
 
 [n-1:0] Write Data

                }
            }
        }
        register MT_WD_WDATA_17 @0x88 {
            bytes 4;
            field mt_wd_wdata_17 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Write data mask and data for the arbitrary pattern generator. Bit fields are organized as follows:
 
 [n+n/8-1:n] Write data mask
 
 [n-1:0] Write Data

                }
            }
        }
        register MT_EX_WDATA_0 @0x8c {
            bytes 4;
            field mt_ex_wdata_0 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Expect data and compare mask for the arbitrary pattern generator. Bit fields are organized as follows:
 
 [n+n/8-1:n] Compare mask
 
 [n-1:0] Expect data

                }
            }
        }
        register MT_EX_WDATA_1 @0x90 {
            bytes 4;
            field mt_ex_wdata_1 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Expect data and compare mask for the arbitrary pattern generator. Bit fields are organized as follows:
 
 [n+n/8-1:n] Compare mask
 
 [n-1:0] Expect data

                }
            }
        }
        register MT_EX_WDATA_2 @0x94 {
            bytes 4;
            field mt_ex_wdata_2 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Expect data and compare mask for the arbitrary pattern generator. Bit fields are organized as follows:
 
 [n+n/8-1:n] Compare mask
 
 [n-1:0] Expect data

                }
            }
        }
        register MT_EX_WDATA_3 @0x98 {
            bytes 4;
            field mt_ex_wdata_3 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Expect data and compare mask for the arbitrary pattern generator. Bit fields are organized as follows:
 
 [n+n/8-1:n] Compare mask
 
 [n-1:0] Expect data

                }
            }
        }
        register MT_EX_WDATA_4 @0x9c {
            bytes 4;
            field mt_ex_wdata_4 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Expect data and compare mask for the arbitrary pattern generator. Bit fields are organized as follows:
 
 [n+n/8-1:n] Compare mask
 
 [n-1:0] Expect data

                }
            }
        }
        register MT_EX_WDATA_5 @0xa0 {
            bytes 4;
            field mt_ex_wdata_5 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Expect data and compare mask for the arbitrary pattern generator. Bit fields are organized as follows:
 
 [n+n/8-1:n] Compare mask
 
 [n-1:0] Expect data

                }
            }
        }
        register MT_EX_WDATA_6 @0xa4 {
            bytes 4;
            field mt_ex_wdata_6 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Expect data and compare mask for the arbitrary pattern generator. Bit fields are organized as follows:
 
 [n+n/8-1:n] Compare mask
 
 [n-1:0] Expect data

                }
            }
        }
        register MT_EX_WDATA_7 @0xa8 {
            bytes 4;
            field mt_ex_wdata_7 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Expect data and compare mask for the arbitrary pattern generator. Bit fields are organized as follows:
 
 [n+n/8-1:n] Compare mask
 
 [n-1:0] Expect data

                }
            }
        }
        register MT_EX_WDATA_8 @0xac {
            bytes 4;
            field mt_ex_wdata_8 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Expect data and compare mask for the arbitrary pattern generator. Bit fields are organized as follows:
 
 [n+n/8-1:n] Compare mask
 
 [n-1:0] Expect data

                }
            }
        }
        register MT_EX_WDATA_9 @0xb0 {
            bytes 4;
            field mt_ex_wdata_9 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Expect data and compare mask for the arbitrary pattern generator. Bit fields are organized as follows:
 
 [n+n/8-1:n] Compare mask
 
 [n-1:0] Expect data

                }
            }
        }
        register MT_EX_WDATA_10 @0xb4 {
            bytes 4;
            field mt_ex_wdata_10 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Expect data and compare mask for the arbitrary pattern generator. Bit fields are organized as follows:
 
 [n+n/8-1:n] Compare mask
 
 [n-1:0] Expect data

                }
            }
        }
        register MT_EX_WDATA_11 @0xb8 {
            bytes 4;
            field mt_ex_wdata_11 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Expect data and compare mask for the arbitrary pattern generator. Bit fields are organized as follows:
 
 [n+n/8-1:n] Compare mask
 
 [n-1:0] Expect data

                }
            }
        }
        register MT_EX_WDATA_12 @0xbc {
            bytes 4;
            field mt_ex_wdata_12 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Expect data and compare mask for the arbitrary pattern generator. Bit fields are organized as follows:
 
 [n+n/8-1:n] Compare mask
 
 [n-1:0] Expect data

                }
            }
        }
        register MT_EX_WDATA_13 @0xc0 {
            bytes 4;
            field mt_ex_wdata_13 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Expect data and compare mask for the arbitrary pattern generator. Bit fields are organized as follows:
 
 [n+n/8-1:n] Compare mask
 
 [n-1:0] Expect data

                }
            }
        }
        register MT_EX_WDATA_14 @0xc4 {
            bytes 4;
            field mt_ex_wdata_14 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Expect data and compare mask for the arbitrary pattern generator. Bit fields are organized as follows:
 
 [n+n/8-1:n] Compare mask
 
 [n-1:0] Expect data

                }
            }
        }
        register MT_EX_WDATA_15 @0xc8 {
            bytes 4;
            field mt_ex_wdata_15 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Expect data and compare mask for the arbitrary pattern generator. Bit fields are organized as follows:
 
 [n+n/8-1:n] Compare mask
 
 [n-1:0] Expect data

                }
            }
        }
        register MT_EX_WDATA_16 @0xcc {
            bytes 4;
            field mt_ex_wdata_16 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Expect data and compare mask for the arbitrary pattern generator. Bit fields are organized as follows:
 
 [n+n/8-1:n] Compare mask
 
 [n-1:0] Expect data

                }
            }
        }
        register MT_EX_WDATA_17 @0xd0 {
            bytes 4;
            field mt_ex_wdata_17 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Expect data and compare mask for the arbitrary pattern generator. Bit fields are organized as follows:
 
 [n+n/8-1:n] Compare mask
 
 [n-1:0] Expect data

                }
            }
        }
        register MT_AC_WDATA_0 @0xd4 {
            bytes 4;
            field mt_ac_wdata_0 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Address data for the arbitrary pattern generator. Typically the lower 24 to 36 bits are used for the address, depending on the depth of the SDRAM and the number of ranks.
 
 The bits of the full mt_ac_wdata register are defined as follows:

 63             - read (1) or write (0) transaction
 
 62:59          - l_b_size (local burst size) of transaction

 58:57          - reserved

 56             - l_mask_write (LPDDR4 only)
  
 55:ADDR_WIDTH  - reserved

 ADDR_WIDTH-1:0 - l_addr (local interface address)


                }
            }
        }
        register MT_AC_WDATA_1 @0xd8 {
            bytes 4;
            field mt_ac_wdata_1 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Address data for the arbitrary pattern generator. Typically the lower 24 to 36 bits are used for the address, depending on the depth of the SDRAM and the number of ranks.
 
 The bits of the full mt_ac_wdata register are defined as follows:

 63             - read (1) or write (0) transaction
 
 62:59          - l_b_size (local burst size) of transaction

 58:57          - reserved

 56             - l_mask_write (LPDDR4 only)
  
 55:ADDR_WIDTH  - reserved

 ADDR_WIDTH-1:0 - l_addr (local interface address)


                }
            }
        }
        register MT_WD_RDATA_0 @0xdc {
            bytes 4;
            field mt_wd_rdata_0 @'h0 {
                bits 32;
                access ro;
                volatile 1
                hard_reset 'h0;
                doc {
                    Readback port for the Write Data RAM

                }
            }
        }
        register MT_WD_RDATA_1 @0xe0 {
            bytes 4;
            field mt_wd_rdata_1 @'h0 {
                bits 32;
                access ro;
                volatile 1
                hard_reset 'h0;
                doc {
                    Readback port for the Write Data RAM

                }
            }
        }
        register MT_WD_RDATA_2 @0xe4 {
            bytes 4;
            field mt_wd_rdata_2 @'h0 {
                bits 32;
                access ro;
                volatile 1
                hard_reset 'h0;
                doc {
                    Readback port for the Write Data RAM

                }
            }
        }
        register MT_WD_RDATA_3 @0xe8 {
            bytes 4;
            field mt_wd_rdata_3 @'h0 {
                bits 32;
                access ro;
                volatile 1
                hard_reset 'h0;
                doc {
                    Readback port for the Write Data RAM

                }
            }
        }
        register MT_WD_RDATA_4 @0xec {
            bytes 4;
            field mt_wd_rdata_4 @'h0 {
                bits 32;
                access ro;
                volatile 1
                hard_reset 'h0;
                doc {
                    Readback port for the Write Data RAM

                }
            }
        }
        register MT_WD_RDATA_5 @0xf0 {
            bytes 4;
            field mt_wd_rdata_5 @'h0 {
                bits 32;
                access ro;
                volatile 1
                hard_reset 'h0;
                doc {
                    Readback port for the Write Data RAM

                }
            }
        }
        register MT_WD_RDATA_6 @0xf4 {
            bytes 4;
            field mt_wd_rdata_6 @'h0 {
                bits 32;
                access ro;
                volatile 1
                hard_reset 'h0;
                doc {
                    Readback port for the Write Data RAM

                }
            }
        }
        register MT_WD_RDATA_7 @0xf8 {
            bytes 4;
            field mt_wd_rdata_7 @'h0 {
                bits 32;
                access ro;
                volatile 1
                hard_reset 'h0;
                doc {
                    Readback port for the Write Data RAM

                }
            }
        }
        register MT_WD_RDATA_8 @0xfc {
            bytes 4;
            field mt_wd_rdata_8 @'h0 {
                bits 32;
                access ro;
                volatile 1
                hard_reset 'h0;
                doc {
                    Readback port for the Write Data RAM

                }
            }
        }
        register MT_WD_RDATA_9 @0x100 {
            bytes 4;
            field mt_wd_rdata_9 @'h0 {
                bits 32;
                access ro;
                volatile 1
                hard_reset 'h0;
                doc {
                    Readback port for the Write Data RAM

                }
            }
        }
        register MT_WD_RDATA_10 @0x104 {
            bytes 4;
            field mt_wd_rdata_10 @'h0 {
                bits 32;
                access ro;
                volatile 1
                hard_reset 'h0;
                doc {
                    Readback port for the Write Data RAM

                }
            }
        }
        register MT_WD_RDATA_11 @0x108 {
            bytes 4;
            field mt_wd_rdata_11 @'h0 {
                bits 32;
                access ro;
                volatile 1
                hard_reset 'h0;
                doc {
                    Readback port for the Write Data RAM

                }
            }
        }
        register MT_WD_RDATA_12 @0x10c {
            bytes 4;
            field mt_wd_rdata_12 @'h0 {
                bits 32;
                access ro;
                volatile 1
                hard_reset 'h0;
                doc {
                    Readback port for the Write Data RAM

                }
            }
        }
        register MT_WD_RDATA_13 @0x110 {
            bytes 4;
            field mt_wd_rdata_13 @'h0 {
                bits 32;
                access ro;
                volatile 1
                hard_reset 'h0;
                doc {
                    Readback port for the Write Data RAM

                }
            }
        }
        register MT_WD_RDATA_14 @0x114 {
            bytes 4;
            field mt_wd_rdata_14 @'h0 {
                bits 32;
                access ro;
                volatile 1
                hard_reset 'h0;
                doc {
                    Readback port for the Write Data RAM

                }
            }
        }
        register MT_WD_RDATA_15 @0x118 {
            bytes 4;
            field mt_wd_rdata_15 @'h0 {
                bits 32;
                access ro;
                volatile 1
                hard_reset 'h0;
                doc {
                    Readback port for the Write Data RAM

                }
            }
        }
        register MT_WD_RDATA_16 @0x11c {
            bytes 4;
            field mt_wd_rdata_16 @'h0 {
                bits 32;
                access ro;
                volatile 1
                hard_reset 'h0;
                doc {
                    Readback port for the Write Data RAM

                }
            }
        }
        register MT_WD_RDATA_17 @0x120 {
            bytes 4;
            field mt_wd_rdata_17 @'h0 {
                bits 32;
                access ro;
                volatile 1
                hard_reset 'h0;
                doc {
                    Readback port for the Write Data RAM

                }
            }
        }
        register MT_EX_RDATA_0 @0x124 {
            bytes 4;
            field mt_ex_rdata_0 @'h0 {
                bits 32;
                access ro;
                volatile 1
                hard_reset 'h0;
                doc {
                    Readback port for the Expect Data RAM

                }
            }
        }
        register MT_EX_RDATA_1 @0x128 {
            bytes 4;
            field mt_ex_rdata_1 @'h0 {
                bits 32;
                access ro;
                volatile 1
                hard_reset 'h0;
                doc {
                    Readback port for the Expect Data RAM

                }
            }
        }
        register MT_EX_RDATA_2 @0x12c {
            bytes 4;
            field mt_ex_rdata_2 @'h0 {
                bits 32;
                access ro;
                volatile 1
                hard_reset 'h0;
                doc {
                    Readback port for the Expect Data RAM

                }
            }
        }
        register MT_EX_RDATA_3 @0x130 {
            bytes 4;
            field mt_ex_rdata_3 @'h0 {
                bits 32;
                access ro;
                volatile 1
                hard_reset 'h0;
                doc {
                    Readback port for the Expect Data RAM

                }
            }
        }
        register MT_EX_RDATA_4 @0x134 {
            bytes 4;
            field mt_ex_rdata_4 @'h0 {
                bits 32;
                access ro;
                volatile 1
                hard_reset 'h0;
                doc {
                    Readback port for the Expect Data RAM

                }
            }
        }
        register MT_EX_RDATA_5 @0x138 {
            bytes 4;
            field mt_ex_rdata_5 @'h0 {
                bits 32;
                access ro;
                volatile 1
                hard_reset 'h0;
                doc {
                    Readback port for the Expect Data RAM

                }
            }
        }
        register MT_EX_RDATA_6 @0x13c {
            bytes 4;
            field mt_ex_rdata_6 @'h0 {
                bits 32;
                access ro;
                volatile 1
                hard_reset 'h0;
                doc {
                    Readback port for the Expect Data RAM

                }
            }
        }
        register MT_EX_RDATA_7 @0x140 {
            bytes 4;
            field mt_ex_rdata_7 @'h0 {
                bits 32;
                access ro;
                volatile 1
                hard_reset 'h0;
                doc {
                    Readback port for the Expect Data RAM

                }
            }
        }
        register MT_EX_RDATA_8 @0x144 {
            bytes 4;
            field mt_ex_rdata_8 @'h0 {
                bits 32;
                access ro;
                volatile 1
                hard_reset 'h0;
                doc {
                    Readback port for the Expect Data RAM

                }
            }
        }
        register MT_EX_RDATA_9 @0x148 {
            bytes 4;
            field mt_ex_rdata_9 @'h0 {
                bits 32;
                access ro;
                volatile 1
                hard_reset 'h0;
                doc {
                    Readback port for the Expect Data RAM

                }
            }
        }
        register MT_EX_RDATA_10 @0x14c {
            bytes 4;
            field mt_ex_rdata_10 @'h0 {
                bits 32;
                access ro;
                volatile 1
                hard_reset 'h0;
                doc {
                    Readback port for the Expect Data RAM

                }
            }
        }
        register MT_EX_RDATA_11 @0x150 {
            bytes 4;
            field mt_ex_rdata_11 @'h0 {
                bits 32;
                access ro;
                volatile 1
                hard_reset 'h0;
                doc {
                    Readback port for the Expect Data RAM

                }
            }
        }
        register MT_EX_RDATA_12 @0x154 {
            bytes 4;
            field mt_ex_rdata_12 @'h0 {
                bits 32;
                access ro;
                volatile 1
                hard_reset 'h0;
                doc {
                    Readback port for the Expect Data RAM

                }
            }
        }
        register MT_EX_RDATA_13 @0x158 {
            bytes 4;
            field mt_ex_rdata_13 @'h0 {
                bits 32;
                access ro;
                volatile 1
                hard_reset 'h0;
                doc {
                    Readback port for the Expect Data RAM

                }
            }
        }
        register MT_EX_RDATA_14 @0x15c {
            bytes 4;
            field mt_ex_rdata_14 @'h0 {
                bits 32;
                access ro;
                volatile 1
                hard_reset 'h0;
                doc {
                    Readback port for the Expect Data RAM

                }
            }
        }
        register MT_EX_RDATA_15 @0x160 {
            bytes 4;
            field mt_ex_rdata_15 @'h0 {
                bits 32;
                access ro;
                volatile 1
                hard_reset 'h0;
                doc {
                    Readback port for the Expect Data RAM

                }
            }
        }
        register MT_EX_RDATA_16 @0x164 {
            bytes 4;
            field mt_ex_rdata_16 @'h0 {
                bits 32;
                access ro;
                volatile 1
                hard_reset 'h0;
                doc {
                    Readback port for the Expect Data RAM

                }
            }
        }
        register MT_EX_RDATA_17 @0x168 {
            bytes 4;
            field mt_ex_rdata_17 @'h0 {
                bits 32;
                access ro;
                volatile 1
                hard_reset 'h0;
                doc {
                    Readback port for the Expect Data RAM

                }
            }
        }
        register MT_AC_RDATA_0 @0x16c {
            bytes 4;
            field mt_ac_rdata_0 @'h0 {
                bits 32;
                access ro;
                volatile 1
                hard_reset 'h0;
                doc {
                    Readback port for the Address RAM

                }
            }
        }
        register MT_AC_RDATA_1 @0x170 {
            bytes 4;
            field mt_ac_rdata_1 @'h0 {
                bits 32;
                access ro;
                volatile 1
                hard_reset 'h0;
                doc {
                    Readback port for the Address RAM

                }
            }
        }
        register MT_START_ADDR_0 @0x174 {
            bytes 4;
            field reserved @'h1c {
                bits 4;
            }
            field mt_start_addr_0 @'h0 {
                bits 28;
                access rw;
                hard_reset 'h0;
                doc {
                    Address to start memory test at. This port is not used when 'mt_addr_pattern' is set to 0x1 (pseudo-random).

                }
            }
        }
        register MT_ERROR_MASK_0 @0x178 {
            bytes 4;
            field mt_error_mask_0 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Error mask. All bits set in this field will mask read-back errors in corresponding data bits. The 'mt_error_sts' flag will not get set when errors are encountered on those data bits.

                }
            }
        }
        register MT_ERROR_MASK_1 @0x17c {
            bytes 4;
            field mt_error_mask_1 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Error mask. All bits set in this field will mask read-back errors in corresponding data bits. The 'mt_error_sts' flag will not get set when errors are encountered on those data bits.

                }
            }
        }
        register MT_ERROR_MASK_2 @0x180 {
            bytes 4;
            field mt_error_mask_2 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Error mask. All bits set in this field will mask read-back errors in corresponding data bits. The 'mt_error_sts' flag will not get set when errors are encountered on those data bits.

                }
            }
        }
        register MT_ERROR_MASK_3 @0x184 {
            bytes 4;
            field mt_error_mask_3 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Error mask. All bits set in this field will mask read-back errors in corresponding data bits. The 'mt_error_sts' flag will not get set when errors are encountered on those data bits.

                }
            }
        }
        register MT_ERROR_MASK_4 @0x188 {
            bytes 4;
            field mt_error_mask_4 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Error mask. All bits set in this field will mask read-back errors in corresponding data bits. The 'mt_error_sts' flag will not get set when errors are encountered on those data bits.

                }
            }
        }
        register MT_ERROR_MASK_5 @0x18c {
            bytes 4;
            field mt_error_mask_5 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Error mask. All bits set in this field will mask read-back errors in corresponding data bits. The 'mt_error_sts' flag will not get set when errors are encountered on those data bits.

                }
            }
        }
        register MT_ERROR_MASK_6 @0x190 {
            bytes 4;
            field mt_error_mask_6 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Error mask. All bits set in this field will mask read-back errors in corresponding data bits. The 'mt_error_sts' flag will not get set when errors are encountered on those data bits.

                }
            }
        }
        register MT_ERROR_MASK_7 @0x194 {
            bytes 4;
            field mt_error_mask_7 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Error mask. All bits set in this field will mask read-back errors in corresponding data bits. The 'mt_error_sts' flag will not get set when errors are encountered on those data bits.

                }
            }
        }
        register MT_ERROR_MASK_8 @0x198 {
            bytes 4;
            field mt_error_mask_8 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Error mask. All bits set in this field will mask read-back errors in corresponding data bits. The 'mt_error_sts' flag will not get set when errors are encountered on those data bits.

                }
            }
        }
        register MT_ERROR_MASK_9 @0x19c {
            bytes 4;
            field mt_error_mask_9 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Error mask. All bits set in this field will mask read-back errors in corresponding data bits. The 'mt_error_sts' flag will not get set when errors are encountered on those data bits.

                }
            }
        }
        register MT_ERROR_MASK_10 @0x1a0 {
            bytes 4;
            field mt_error_mask_10 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Error mask. All bits set in this field will mask read-back errors in corresponding data bits. The 'mt_error_sts' flag will not get set when errors are encountered on those data bits.

                }
            }
        }
        register MT_ERROR_MASK_11 @0x1a4 {
            bytes 4;
            field mt_error_mask_11 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Error mask. All bits set in this field will mask read-back errors in corresponding data bits. The 'mt_error_sts' flag will not get set when errors are encountered on those data bits.

                }
            }
        }
        register MT_ERROR_MASK_12 @0x1a8 {
            bytes 4;
            field mt_error_mask_12 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Error mask. All bits set in this field will mask read-back errors in corresponding data bits. The 'mt_error_sts' flag will not get set when errors are encountered on those data bits.

                }
            }
        }
        register MT_ERROR_MASK_13 @0x1ac {
            bytes 4;
            field mt_error_mask_13 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Error mask. All bits set in this field will mask read-back errors in corresponding data bits. The 'mt_error_sts' flag will not get set when errors are encountered on those data bits.

                }
            }
        }
        register MT_ERROR_MASK_14 @0x1b0 {
            bytes 4;
            field mt_error_mask_14 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Error mask. All bits set in this field will mask read-back errors in corresponding data bits. The 'mt_error_sts' flag will not get set when errors are encountered on those data bits.

                }
            }
        }
        register MT_ERROR_MASK_15 @0x1b4 {
            bytes 4;
            field mt_error_mask_15 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Error mask. All bits set in this field will mask read-back errors in corresponding data bits. The 'mt_error_sts' flag will not get set when errors are encountered on those data bits.

                }
            }
        }
        register MT_ERROR_MASK_16 @0x1b8 {
            bytes 4;
            field mt_error_mask_16 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Error mask. All bits set in this field will mask read-back errors in corresponding data bits. The 'mt_error_sts' flag will not get set when errors are encountered on those data bits.

                }
            }
        }
        register MT_ERROR_MASK_17 @0x1bc {
            bytes 4;
            field mt_error_mask_17 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Error mask. All bits set in this field will mask read-back errors in corresponding data bits. The 'mt_error_sts' flag will not get set when errors are encountered on those data bits.

                }
            }
        }
        register MT_USER_DATA_PATTERN @0x540 {
            bytes 4;
            field reserved @'h8 {
                bits 24;
            }
            field mt_user_data_pattern @'h0 {
                bits 8;
                access rw;
                hard_reset 'h0;
                doc {
                    User-specified data pattern for use with Algorithmic Pattern Generator, when mt_data_pattern selects user-specified pattern.

                }
            }
        }
        register MT_ALG_AUTO_PCH @0x54c {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field mt_alg_auto_pch @'h0 {
                access rw;
                hard_reset 'h0;
                doc {
                    Causes auto_precharge to be asserted when the memory test is enabled and the algorithmic pattern generator is being used.

                }
            }
        }
    }
    block MPFE @0x4c00 {
        bytes 4;
        register CFG_STARVE_TIMEOUT_P0 @0x0 {
            bytes 4;
            field reserved @'hc {
                bits 20;
            }
            field cfg_starve_timeout_p0 @'h0 {
                bits 12;
                access rw;
                hard_reset 'h0;
                doc {
                    Amount of time that may elapse (in system clocks) before this port is serviced. If a request is pending to this port for a period of time longer than 'cfg_starve_timeout_pN', it will automatically be promoted to the highest priority and serviced next.  Any port having this value set to '0' will have its starvation timeout disabled.

                }
            }
        }
        register CFG_STARVE_TIMEOUT_P1 @0x4 {
            bytes 4;
            field reserved @'hc {
                bits 20;
            }
            field cfg_starve_timeout_p1 @'h0 {
                bits 12;
                access rw;
                hard_reset 'h0;
                doc {
                    Amount of time that may elapse (in system clocks) before this port is serviced. If a request is pending to this port for a period of time longer than 'cfg_starve_timeout_pN', it will automatically be promoted to the highest priority and serviced next.  Any port having this value set to '0' will have its starvation timeout disabled.

                }
            }
        }
        register CFG_STARVE_TIMEOUT_P2 @0x8 {
            bytes 4;
            field reserved @'hc {
                bits 20;
            }
            field cfg_starve_timeout_p2 @'h0 {
                bits 12;
                access rw;
                hard_reset 'h0;
                doc {
                    Amount of time that may elapse (in system clocks) before this port is serviced. If a request is pending to this port for a period of time longer than 'cfg_starve_timeout_pN', it will automatically be promoted to the highest priority and serviced next.  Any port having this value set to '0' will have its starvation timeout disabled.

                }
            }
        }
        register CFG_STARVE_TIMEOUT_P3 @0xc {
            bytes 4;
            field reserved @'hc {
                bits 20;
            }
            field cfg_starve_timeout_p3 @'h0 {
                bits 12;
                access rw;
                hard_reset 'h0;
                doc {
                    Amount of time that may elapse (in system clocks) before this port is serviced. If a request is pending to this port for a period of time longer than 'cfg_starve_timeout_pN', it will automatically be promoted to the highest priority and serviced next.  Any port having this value set to '0' will have its starvation timeout disabled.

                }
            }
        }
        register CFG_STARVE_TIMEOUT_P4 @0x10 {
            bytes 4;
            field reserved @'hc {
                bits 20;
            }
            field cfg_starve_timeout_p4 @'h0 {
                bits 12;
                access rw;
                hard_reset 'h0;
                doc {
                    Amount of time that may elapse (in system clocks) before this port is serviced. If a request is pending to this port for a period of time longer than 'cfg_starve_timeout_pN', it will automatically be promoted to the highest priority and serviced next.  Any port having this value set to '0' will have its starvation timeout disabled.

                }
            }
        }
        register CFG_STARVE_TIMEOUT_P5 @0x14 {
            bytes 4;
            field reserved @'hc {
                bits 20;
            }
            field cfg_starve_timeout_p5 @'h0 {
                bits 12;
                access rw;
                hard_reset 'h0;
                doc {
                    Amount of time that may elapse (in system clocks) before this port is serviced. If a request is pending to this port for a period of time longer than 'cfg_starve_timeout_pN', it will automatically be promoted to the highest priority and serviced next.  Any port having this value set to '0' will have its starvation timeout disabled.

                }
            }
        }
        register CFG_STARVE_TIMEOUT_P6 @0x18 {
            bytes 4;
            field reserved @'hc {
                bits 20;
            }
            field cfg_starve_timeout_p6 @'h0 {
                bits 12;
                access rw;
                hard_reset 'h0;
                doc {
                    Amount of time that may elapse (in system clocks) before this port is serviced. If a request is pending to this port for a period of time longer than 'cfg_starve_timeout_pN', it will automatically be promoted to the highest priority and serviced next.  Any port having this value set to '0' will have its starvation timeout disabled.

                }
            }
        }
        register CFG_STARVE_TIMEOUT_P7 @0x1c {
            bytes 4;
            field reserved @'hc {
                bits 20;
            }
            field cfg_starve_timeout_p7 @'h0 {
                bits 12;
                access rw;
                hard_reset 'h0;
                doc {
                    Amount of time that may elapse (in system clocks) before this port is serviced. If a request is pending to this port for a period of time longer than 'cfg_starve_timeout_pN', it will automatically be promoted to the highest priority and serviced next.  Any port having this value set to '0' will have its starvation timeout disabled.

                }
            }
        }
    }
    block REORDER @0x5000 {
        bytes 4;
        register CFG_REORDER_EN @0x0 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field cfg_reorder_en @'h0 {
                access rw;
                hard_reset 'h1;
                doc {
                    Enable for request reordering.
 
 0 - Request reordering disabled
 
 1 - Request reordering enabled
 
 This port is only used in configurations of the Reorder Core where request reordering is supported. Refer to section 3.4 for details
 on request reordering.
 
 When this port is set to '1' and 'cfg_reorder_queue_en' is also '1', reordering of buffered entries is enabled, otherwise the buffered entries are issued in fifo order. If 'cfg_reorder_queue_en' is set to '0', cfg_reorder_en is a don't care. 

                }
            }
        }
        register CFG_REORDER_QUEUE_EN @0x4 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field cfg_reorder_queue_en @'h0 {
                access rw;
                hard_reset 'h1;
                doc {
                    Reorder queue enable. When set to '1', allows requests to stack up in reorder queue. Reordering will occur if 'cfg_reorder_en' is also set to 1.
 
 This port is only used in configurations of the Reorder Core where request reordering is supported. Refer to section section 3.4 for details on request reordering.
 
 This port is typically only provided for ASIC configurations. Under normal circumstances this port will always be set to '1'. It is provided for debugging purposes.

                }
            }
        }
        register CFG_INTRAPORT_REORDER_EN @0x8 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field cfg_intraport_reorder_en @'h0 {
                access rw;
                hard_reset 'h1;
                doc {
                    Enable intra-port reordering.
 
 0 - Intra-port request reordering disabled
 
 1 - Intra-port request reordering enabled
 
 This port is ignored if cfg_reorder_en is set to '0'. Refer to section section 3.4 for details on request reordering and intraport reordering.

                }
            }
        }
        register CFG_MAINTAIN_COHERENCY @0xc {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field cfg_maintain_coherency @'h0 {
                access rw;
                hard_reset 'h1;
                doc {
                    Causes data coherency to be maintained by preventing reordering of requests addressing the same memory region. Refer to Reorder Core User Guide for a description of memory regions. 

                }
            }
        }
        register CFG_Q_AGE_LIMIT @0x10 {
            bytes 4;
            field reserved @'h6 {
                bits 26;
            }
            field cfg_q_age_limit @'h0 {
                bits 6;
                access rw;
                hard_reset 'h3f;
                doc {
                    Reorder core queue entry age limit. The age limit value prevents the oldest entry in the queue from being 'stuck' in the reorder queue for too long. When the oldest entry in the queue changes, the age limit counter is reset and starts counting.  Each time a newer  entry exits the reorder queue (has been issued to the controller) without the  oldest entry in the queue being issued, the 'age' of the oldest entry in the queue is incremented. If cfg_q_age_limit newer entries are issued before the oldest entry is issued, then the oldest entry in the queue becomes the highest priority and is always issued next. The width of the cfg_q_age_limit value is set by the parameter QUEUE_AGE_BITS. QUEUE_AGE_BITS can be set to as small as 1 (but this is not recommended) and can be set to as large of a value that the application needs; however when using cfg_q_age_limit values larger than the REORDER_QUEUE_DEPTH, this can result in the oldest entry being "stuck" in the queue for too long. 

 This port is only useful in configurations of the Reorder Core where request reordering is supported.  Refer to section 3.4 for details on request reordering. Both 'cfg_reorder_en' and 'cfg_reorder_queue_en' must be set to '1'.  When either of these configuration bits are set to 0, the reorder queue entries are issued in the order that they arrived at the input to the reorder queue.

                }
            }
        }
        register CFG_SBREF_ISSUE_PER @0x14 {
            bytes 4;
            field reserved @'ha {
                bits 22;
            }
            field cfg_sbref_issue_per @'h0 {
                bits 10;
                access rw;
                hard_reset 'h1f;
                doc {
                    This register is used to optimize performance by changing the minimum period used to issue each subsequent single bank refresh command from the Reorder Core when cfg_sbref_en is set to 1. This parameter is overridden in the Reorder core if 7/(8*(2^cfg_mem_bankbits)) * temperature compensated refresh period (measured in full-rate memory clocks) is less than the cfg_sbref_issue_per value (also given in full-rate memory clocks). This is done to insure that a full single bank refresh cycle is completed within the temperature compensated refresh period (temperature compensated all banks refresh period). If this value is set below FREQ_RATIO*2, it will result in the Reorder core issuing single bank refresh requests every other dfi_clk (provided the NWL controller core isn't busy). 

Note that this configuration value is only used in conjunction with deliveries that support HBM  memory and that contain the Reorder core.

                }
            }
        }
        register CFG_REORDER_RW_ONLY @0x1c {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field cfg_reorder_rw_only @'h0 {
                access rw;
                hard_reset 'h0;
                doc {
                    Reorder core read/write reordering only.  When this bit is set, the reorder core adjusts its reordering algorithm (currently only when using Criteria 0)to maximize the grouping of reads and writes together (normal Criteria 0 filtering is not used). Switching between issuing reads and writes only occur if one of the following things occur:
 o   Issuing a stream of reads (or writes) and there are no more coherent, priority-enabled  reads (or writes) to issue
 o   The oldest entry in the reorder queue times out.
Note that if cfg_manual_address_map is set and reordering is enabled, then the cfg_reorder_rw_only bit should normally be set as well (normal reordering algorithms will not work as expected if using manual address mapping in the controller core).
When cfg_reorder_rw_only is clear and reordering is enabled, then the normal filtering algorithm is used to select the next request to issue from the reorder core.

                }
            }
        }
        register CFG_RO_PRIORITY_EN @0x20 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field cfg_ro_priority_en @'h0 {
                access rw;
                hard_reset 'h0;
                doc {
                    Reorder_core QOS/priority enable.  When this bit is set (and REORDER_PRIORITY_ENABLE paramter was set during synthesis), the reorder core will normally send out only requests that have the highest priority (except if the oldest entry in the reorder core  has aged/timed-out). If clear (or the REORDER_PRIORITY_ENABLE parameter was clear during synthesis), the reorder core ignores any incoming priority and selects the next request from the reorder_queue to maximize bandwidth/performance.

                }
            }
        }
        register CFG_RO_DELAY_BADPERF_CHOICE @0x24 {
            bytes 4;
            field reserved @'h3 {
                bits 29;
            }
            field cfg_ro_delay_badperf_choice @'h0 {
                bits 3;
                access rw;
                hard_reset 'h3;
                doc {
                    This 3-bit register controls the number DFI clock cycles that the reorder core may avoid selecting a new output request, when the only requests available would cause a significant bandwidth hiccup in the controller. A value of n in this register causes the reorder core to delay upto n+1 cycles before selecting/issuing the next request. If a "good" request choice (one that doesn't impact bandwidth) or an "age_limit timeout" becomes available before this timer expires, the timer is reset and the "better" or "age_limit" choice request is selected/output. Note that programming a larger value into this field gives the reorder core extra cycles to both get new incoming requests and to recategorize existing requests into requests that won't cause bandwidth hiccups; however, a larger value also gives the controller less time to be able to perform precharge and/or activate lookahead which, in turn, can lead to poorer performance.

                }
            }
        }
    }
    block RMW @0x5400 {
        bytes 4;
        register CFG_DM_EN @0x0 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field cfg_dm_en @'h0 {
                access rw;
                hard_reset 'h0;
                doc {
                    When set to '1' the RMW Core will use data mask signals to the memory in order to optimize certain RMW operations. This port must be set to '0' if the DRAM data mask signals are not connected to the memory devices.

                }
            }
        }
        register CFG_RMW_EN @0x4 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field cfg_rmw_en @'h0 {
                access rw;
                hard_reset 'h1;
                doc {
                    Enable or disable RMW.
 
 0 - disables RMW operations.
 
 1 - enables RMW operations.
 
 When disabled, the RMW Core requires that the memory support data mask functionality (no ECC, data mask pins connected through to memory devices) and cfg_dm_en must be set to '1'.

 A setting of '0' also enables use of the 'l_dm_in' data mask inputs when the local interface is used.

                }
            }
        }
    }
    block ECC @0x5800 {
        bytes 4;
        register CFG_ECC_CORRECTION_EN @0x0 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field cfg_ecc_correction_en @'h0 {
                access rw;
                hard_reset 'h1;
                doc {
                    Enables ECC error correction and detection
 
 0x1 - Correction and detection function is enabled, 1 bit errors will be corrected, multi-bit errors will not be corrected. Errors occurring in an odd number of bits (3,5,7, etc.) could have additional bit inversions due to attempted correction.
 
 0x0 - Correction and detection function is disabled. ECC errors are not reported.

                }
            }
        }
        register CFG_ECC_BYPASS @0x40 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field cfg_ecc_bypass @'h0 {
                access rw;
                hard_reset 'h0;
                doc {
                    When set to 1, the controller will not compute ECC check data or perform ECC correction on received data.  When in ECC bypass mode, axiN_wdata_parity input pins are repurposed to be the data that gets written to ECC memory.  Likewise, axiN_rdata_parity outputs are repurposed to be the data that gets read out of ECC memory.

                }
            }
        }
        register INIT_WRITE_DATA_1B_ECC_ERROR_GEN @0x44 {
            bytes 4;
            field reserved @'h8 {
                bits 24;
            }
            field init_write_data_1b_ecc_error_gen @'h0 {
                bits 8;
                access rw;
                hard_reset 'h0;
                doc {
                    Memory controller write data path 1-bit ECC error generation. This register contains one bit per 64-bits (ECC generators are used per 64-bits of data path width) of user interface data path width. When set, will invert the corresponding ECC generator's least significant ECC check bit (causing a 1-bit ECC error) on the next cycle of write data. Error generation will persist for only one cycle. To cause a subsequent 1-bit ECC error generation cycle,  a bit must be written to 0 and then back to 1. 

                }
            }
        }
        register INIT_WRITE_DATA_2B_ECC_ERROR_GEN @0x48 {
            bytes 4;
            field reserved @'h8 {
                bits 24;
            }
            field init_write_data_2b_ecc_error_gen @'h0 {
                bits 8;
                access rw;
                hard_reset 'h0;
                doc {
                    Memory controller write data path 2-bit ECC error generation. This register contains one bit per 64-bits (ECC generators are used per 64-bits of data path width) of user interface data path width. When set, will invert the corresponding ECC generator's 2 most significant of the 3 least significant ECC check bits (causing a 2-bit ECC error) on the next cycle of write data. Error generation will persist for only one cycle. To cause a subsequent 2-bit ECC error generation cycle,  a bit must be written to 0 and then back to 1. 

                }
            }
        }
        register CFG_ECC_1BIT_INT_THRESH @0x5c {
            bytes 4;
            field reserved @'h8 {
                bits 24;
            }
            field cfg_ecc_1bit_int_thresh @'h0 {
                bits 8;
                access rw;
                hard_reset 'h0;
                doc {
                    This 8-bit value defines the number of ECC 1-bit error corrections that must be exceeded before the stat_int_ecc_1bit_thresh status bit (and interrupt output pin) are set and the error summing register is cleared to start summing new ECC 1bit error correction counts. Setting this value to 0 means that each new correctable ecc error will signal an interrupt/set the status bit.  Setting this value to the maximum value of 0xff will disable generating the interrupt and interrupt status. Note that if the parity error retry module is included, 1bit error corrections signaled into that unit are not counted and only the 1bit corrected errors that are passed on to the user logic interface from this unit are counted. Also if the RMW unit is included and a read prefetch is performed to allow data to be merged with a user write and the read prefetch results in a 1bit ecc correction, this 1bit correction will be counted by the ecc_1bit_int_threshold detection logic. Finally, if the ECC Scrub logic is included, any ECC corrections deteted by this unit will also be counted. 

                }
            }
        }
        register STAT_INT_ECC_1BIT_THRESH @0x60 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field stat_int_ecc_1bit_thresh @'h0 {
                access rc;
                volatile 1
                hard_reset 'h0;
                doc {
                    This bit is set when the number of 1bit ECC error corrections is greater-than the cfg_ecc_1bit_thresh.  This status bit should be read to clear the status and associated interrupt pin output as soon as possible, to avoid missing the setting of this status/interrupt due to new 1bit ECC error corrections. 

                }
            }
        }
    }
    block ADV_MEM_TEST @0x6000 {
        bytes 4;
        register AMT_USEQ_IRAM_WADDR @0x0 {
            bytes 4;
            field reserved @'h6 {
                bits 26;
            }
            field amt_useq_iram_waddr @'h0 {
                bits 6;
                access rw;
                hard_reset 'h0;
                doc {
                    Set the address for reading from or writing to the AMT micro sequencer instruction RAM.  Once set, the read or write address is incremented on each read or write access.

                }
            }
        }
        register AMT_USEQ_IRAM_WDATA_0 @0xc {
            bytes 4;
            field amt_useq_iram_wdata_0 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Data to be written to the AMT micro sequencer instruction RAM.  The initial write location is set using the amt_useq_iram_waddr CSR register and is incremented by the logic with each write.

                }
            }
        }
        register AMT_USEQ_IRAM_WDATA_1 @0x10 {
            bytes 4;
            field reserved @'h10 {
                bits 16;
            }
            field amt_useq_iram_wdata_1 @'h0 {
                bits 16;
                access rw;
                hard_reset 'h0;
                doc {
                    Data to be written to the AMT micro sequencer instruction RAM.  The initial write location is set using the amt_useq_iram_waddr CSR register and is incremented by the logic with each write.

                }
            }
        }
        register AMT_USEQ_IRAM_RDATA_0 @0x24 {
            bytes 4;
            field amt_useq_iram_rdata_0 @'h0 {
                bits 32;
                access ro;
                volatile 1
                hard_reset 'h0;
                doc {
                    Data read from the AMT micro sequencer instruction RAM.  The initial read location is set using the amt_useq_iram_waddr CSR register and is incremented by the logic with each read.

                }
            }
        }
        register AMT_USEQ_IRAM_RDATA_1 @0x28 {
            bytes 4;
            field reserved @'h10 {
                bits 16;
            }
            field amt_useq_iram_rdata_1 @'h0 {
                bits 16;
                access ro;
                volatile 1
                hard_reset 'h0;
                doc {
                    Data read from the AMT micro sequencer instruction RAM.  The initial read location is set using the amt_useq_iram_waddr CSR register and is incremented by the logic with each read.

                }
            }
        }
        register AMT_USEQ_IRAM_ACK @0x3c {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field amt_useq_iram_ack @'h0 {
                access rc;
                volatile 1
                hard_reset 'h0;
                doc {
                    Indicates read or write of AMT micro sequencer instruction RAM has been accepted.

                }
            }
        }
        register AMT_USEQ_RF_WADDR @0x48 {
            bytes 4;
            field reserved @'h5 {
                bits 27;
            }
            field amt_useq_rf_waddr @'h0 {
                bits 5;
                access rw;
                hard_reset 'h0;
                doc {
                    Set the address for reading from or writing to the AMT micro sequencer register file.  Once set, the read or write address is incremented on each read or write access.

                }
            }
        }
        register AMT_USEQ_RF_WDATA_0 @0x54 {
            bytes 4;
            field amt_useq_rf_wdata_0 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Data to be written to the AMT micro sequencer register file.  The initial write location is set using the amt_useq_rf_waddr CSR register and is incremented by the logic with each write.

                }
            }
        }
        register AMT_USEQ_RF_RDATA_0 @0x60 {
            bytes 4;
            field amt_useq_rf_rdata_0 @'h0 {
                bits 32;
                access ro;
                volatile 1
                hard_reset 'h0;
                doc {
                    Data read from the AMT micro sequencer register file.  The initial read location is set using the amt_useq_rf_waddr CSR register and is incremented by the logic with each read.

                }
            }
        }
        register AMT_USEQ_RF_ACK @0x6c {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field amt_useq_rf_ack @'h0 {
                access rc;
                volatile 1
                hard_reset 'h0;
                doc {
                    Indicates read or write of AMT micro sequencer register file has been accepted.

                }
            }
        }
        register AMT_USEQ_EXCEPTIONS @0x78 {
            bytes 4;
            field amt_useq_exceptions @'h0 {
                bits 32;
                access ro;
                volatile 1
                hard_reset 'h0;
                doc {
                    AMT micro sequencer exceptions register.  If exceptions are encountered while the micro program is executing, they will be recorded in this register.  The register is cleared by the logic each time a micro program is enabled.

                }
            }
        }
        register AMT_USEQ_PC @0x84 {
            bytes 4;
            field reserved @'h6 {
                bits 26;
            }
            field amt_useq_pc @'h0 {
                bits 6;
                access ro;
                volatile 1
                hard_reset 'h0;
                doc {
                    AMT micro sequencer program counter.  This is the current value of the instruction RAM read pointer in the micro sequencer.

                }
            }
        }
        register AMT_USEQ_INST_COUNTER_0 @0x90 {
            bytes 4;
            field amt_useq_inst_counter_0 @'h0 {
                bits 32;
                access ro;
                volatile 1
                hard_reset 'h0;
                doc {
                    AMT micro sequencer instruction counter.  After a micro program completes, this register contains the number of instructions executed by the micro sequencer.  This counter value accounts for loops and jumps in the micro program that would not be represented in the program counter register.

                }
            }
        }
        register AMT_USEQ_INST_COUNTER_1 @0x94 {
            bytes 4;
            field reserved @'h12 {
                bits 14;
            }
            field amt_useq_inst_counter_1 @'h0 {
                bits 18;
                access ro;
                volatile 1
                hard_reset 'h0;
                doc {
                    AMT micro sequencer instruction counter.  After a micro program completes, this register contains the number of instructions executed by the micro sequencer.  This counter value accounts for loops and jumps in the micro program that would not be represented in the program counter register.

                }
            }
        }
        register AMT_USEQ_MTA_STORAGE_SEL @0xac {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field amt_useq_mta_storage_sel @'h0 {
                access rw;
                hard_reset 'h0;
                doc {
                    When using the memory test analyzer (MTA) with the micro sequencer in the advanced memory test module, the user has a choice of storing either the contents of the r0 and r1 registers or the instruction counter in the MTA.  By setting this register to 1'b0, the contents of the r0 and r1 registers are recorded when the MTA storage is triggered.  Setting this register to a 1'b1 causes the instruction counter value at the time of the read request to be recorded.

                }
            }
        }
        register AMT_SYNCHRONIZE_ENABLE @0xb8 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field amt_synchronize_enable @'h0 {
                access rw;
                hard_reset 'h0;
                doc {
                    This register is used to synchronize the AMT enables for multiple AMTs in the device.  When set to 1'b1, will cause the mt_en or mt_en_single to the AMT to be masked until the mt_en or mt_en_single to all AMT instances with this bit set have been enabled.

                }
            }
        }
        register AMT_SEQUENCER_ENABLE @0xc4 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field amt_sequencer_enable @'h0 {
                access rw;
                hard_reset 'h0;
                doc {
                    This register is used to enable the micro sequencer in the AMT.  When set the other pattern generators in the memory test core (algorithmic and arbitrary) are disabled.  With this enabled the micro program is started by asserting either mt_en or mt_en_single.

                }
            }
        }
    }
    block MTA @0x6400 {
        bytes 4;
        register CFG_ERROR_GROUP_SEL @0x0 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field cfg_error_group_sel @'h0 {
                access rw;
                hard_reset 'h0;
                doc {
                    Specify compressed error bus or actual data bytes for storage.  Refer to Memory Test Analyzer Core User Guide.

 0 - Actual bytes/byte lanes are stored

 1 - Compressed error bus stored.

                }
            }
        }
        register CFG_DATA_SEL @0x4 {
            bytes 4;
            field reserved @'h7 {
                bits 25;
            }
            field cfg_data_sel @'h0 {
                bits 7;
                access rw;
                hard_reset 'h0;
                doc {
                    Select byte lane or compressed error bus for storage. Refer to the Memory Test Analyzer Core User Guide.

                }
            }
        }
        register CFG_TRIG_MODE @0x8 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field cfg_trig_mode @'h0 {
                access rw;
                hard_reset 'h0;
                doc {
                    Used by the Memory Test Analyzer Core and Data Analyzer Core.  Refer to the respective core User Guides for details.

 If 1: Acquisition acquires continuously on acq_en, stopping after the trigger by cfg_acq_cycs_post_trig.

 If 0: Acquisition acquires without trigger on acq_en

                }
            }
        }
        register CFG_POST_TRIG_CYCS @0xc {
            bytes 4;
            field reserved @'h5 {
                bits 27;
            }
            field cfg_post_trig_cycs @'h0 {
                bits 5;
                access rw;
                hard_reset 'h0;
                doc {
                    Defines the number of acq_en qualified cycles to store after the trigger (including the trigger cycle)

                }
            }
        }
        register CFG_TRIG_MASK @0x10 {
            bytes 4;
            field reserved @'h3 {
                bits 29;
            }
            field cfg_trig_mask @'h0 {
                bits 3;
                access rw;
                hard_reset 'h0;
                doc {
                    Bits of AND trigger bus to mask (address match, error, valid = [2:0]). Refer to the Memory Test Analyzer Core User Guide.

 Trigger on:

 3'b000 - valid cycles where error occurs on an address match

 3'b010 - valid cycles with an address match

 3'b100 - valid cycles with an error

 3'b110 - valid cycles

 All other bit combinations reserved.

                }
            }
        }
        register CFG_EN_MASK @0x14 {
            bytes 4;
            field reserved @'h2 {
                bits 30;
            }
            field cfg_en_mask @'h0 {
                bits 2;
                access rw;
                hard_reset 'h0;
                doc {
                    Bits of AND enable bus to mask (error, valid = [1:0]). Refer to the Memory Test Analyzer Core User Guide.

 Store data in Acquisition Memory on:

 2'b00 - Valid cycles containing errors

 2'b10 - Valid cycles

 All other bit combinations reserved.

                }
            }
        }
        register MTC_ACQ_ADDR @0x18 {
            bytes 4;
            field reserved @'h4 {
                bits 28;
            }
            field mtc_acq_addr @'h0 {
                bits 4;
                access rw;
                hard_reset 'h0;
                doc {
                    Address to initialize Capture Memory Address (with 'acq_addr_wr_en')

                }
            }
        }
        register MTC_ACQ_CYCS_STORED @0x1c {
            bytes 4;
            field reserved @'h5 {
                bits 27;
            }
            field mtc_acq_cycs_stored @'h0 {
                bits 5;
                access ro;
                volatile 1
                hard_reset 'h0;
                doc {
                    Number of vectors stored with last armed acquisition. Note: This value is not synchonized for CSR readout with coherency of the bits. It is assumed that this register is only read when the memory test is idle. 

                }
            }
        }
        register MTC_ACQ_TRIG_DETECT @0x20 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field mtc_acq_trig_detect @'h0 {
                access ro;
                volatile 1
                hard_reset 'h0;
                doc {
                    Indicates if trigger was detected in last armed acquisition

                }
            }
        }
        register MTC_ACQ_MEM_TRIG_ADDR @0x24 {
            bytes 4;
            field reserved @'h4 {
                bits 28;
            }
            field mtc_acq_mem_trig_addr @'h0 {
                bits 4;
                access ro;
                volatile 1
                hard_reset 'h0;
                doc {
                    Memory address corresponding to trigger vector. Note: This value is not synchonized for CSR readout with coherency of the bits. It is assumed that this register is only read when the memory test is idle.

                }
            }
        }
        register MTC_ACQ_MEM_LAST_ADDR @0x28 {
            bytes 4;
            field reserved @'h4 {
                bits 28;
            }
            field mtc_acq_mem_last_addr @'h0 {
                bits 4;
                access ro;
                volatile 1
                hard_reset 'h0;
                doc {
                    Memory address of last stored vector. Note: This value is not synchonized for CSR readout with coherency of the bits. It is assumed that this register is only read when the memory test is idle.

                }
            }
        }
        register MTC_ACK @0x2c {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field mtc_ack @'h0 {
                access rc;
                volatile 1
                hard_reset 'h0;
                doc {
                    Set to acknowledge completion of read or write of acquisition memory, or to write of acquisition memory address in Memory Test Analyzer Core.

                }
            }
        }
        register CFG_TRIG_MT_ADDR_0 @0x30 {
            bytes 4;
            field reserved @'h1c {
                bits 4;
            }
            field cfg_trig_mt_addr_0 @'h0 {
                bits 28;
                access rw;
                hard_reset 'h0;
                doc {
                    Specify match address for triggered address mode

                }
            }
        }
        register CFG_TRIG_ERR_MASK_0 @0x34 {
            bytes 4;
            field cfg_trig_err_mask_0 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Per-bit mask for memory errors (affect trigger, enable, and error acquisition)

                }
            }
        }
        register CFG_TRIG_ERR_MASK_1 @0x38 {
            bytes 4;
            field cfg_trig_err_mask_1 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Per-bit mask for memory errors (affect trigger, enable, and error acquisition)

                }
            }
        }
        register CFG_TRIG_ERR_MASK_2 @0x3c {
            bytes 4;
            field cfg_trig_err_mask_2 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Per-bit mask for memory errors (affect trigger, enable, and error acquisition)

                }
            }
        }
        register CFG_TRIG_ERR_MASK_3 @0x40 {
            bytes 4;
            field cfg_trig_err_mask_3 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Per-bit mask for memory errors (affect trigger, enable, and error acquisition)

                }
            }
        }
        register CFG_TRIG_ERR_MASK_4 @0x44 {
            bytes 4;
            field cfg_trig_err_mask_4 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Per-bit mask for memory errors (affect trigger, enable, and error acquisition)

                }
            }
        }
        register CFG_TRIG_ERR_MASK_5 @0x48 {
            bytes 4;
            field cfg_trig_err_mask_5 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Per-bit mask for memory errors (affect trigger, enable, and error acquisition)

                }
            }
        }
        register CFG_TRIG_ERR_MASK_6 @0x4c {
            bytes 4;
            field cfg_trig_err_mask_6 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Per-bit mask for memory errors (affect trigger, enable, and error acquisition)

                }
            }
        }
        register CFG_TRIG_ERR_MASK_7 @0x50 {
            bytes 4;
            field cfg_trig_err_mask_7 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Per-bit mask for memory errors (affect trigger, enable, and error acquisition)

                }
            }
        }
        register CFG_TRIG_ERR_MASK_8 @0x54 {
            bytes 4;
            field cfg_trig_err_mask_8 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Per-bit mask for memory errors (affect trigger, enable, and error acquisition)

                }
            }
        }
        register CFG_TRIG_ERR_MASK_9 @0x58 {
            bytes 4;
            field cfg_trig_err_mask_9 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Per-bit mask for memory errors (affect trigger, enable, and error acquisition)

                }
            }
        }
        register CFG_TRIG_ERR_MASK_10 @0x5c {
            bytes 4;
            field cfg_trig_err_mask_10 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Per-bit mask for memory errors (affect trigger, enable, and error acquisition)

                }
            }
        }
        register CFG_TRIG_ERR_MASK_11 @0x60 {
            bytes 4;
            field cfg_trig_err_mask_11 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Per-bit mask for memory errors (affect trigger, enable, and error acquisition)

                }
            }
        }
        register CFG_TRIG_ERR_MASK_12 @0x64 {
            bytes 4;
            field cfg_trig_err_mask_12 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Per-bit mask for memory errors (affect trigger, enable, and error acquisition)

                }
            }
        }
        register CFG_TRIG_ERR_MASK_13 @0x68 {
            bytes 4;
            field cfg_trig_err_mask_13 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Per-bit mask for memory errors (affect trigger, enable, and error acquisition)

                }
            }
        }
        register CFG_TRIG_ERR_MASK_14 @0x6c {
            bytes 4;
            field cfg_trig_err_mask_14 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Per-bit mask for memory errors (affect trigger, enable, and error acquisition)

                }
            }
        }
        register CFG_TRIG_ERR_MASK_15 @0x70 {
            bytes 4;
            field cfg_trig_err_mask_15 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Per-bit mask for memory errors (affect trigger, enable, and error acquisition)

                }
            }
        }
        register CFG_TRIG_ERR_MASK_16 @0x74 {
            bytes 4;
            field cfg_trig_err_mask_16 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Per-bit mask for memory errors (affect trigger, enable, and error acquisition)

                }
            }
        }
        register CFG_TRIG_ERR_MASK_17 @0x78 {
            bytes 4;
            field cfg_trig_err_mask_17 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Per-bit mask for memory errors (affect trigger, enable, and error acquisition)

                }
            }
        }
        register MTC_ACQ_WR_DATA_0 @0x7c {
            bytes 4;
            field mtc_acq_wr_data_0 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Write Data for Capture Memory Debug

                }
            }
        }
        register MTC_ACQ_WR_DATA_1 @0x80 {
            bytes 4;
            field mtc_acq_wr_data_1 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Write Data for Capture Memory Debug

                }
            }
        }
        register MTC_ACQ_WR_DATA_2 @0x84 {
            bytes 4;
            field mtc_acq_wr_data_2 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Write Data for Capture Memory Debug

                }
            }
        }
        register MTC_ACQ_WR_DATA_3 @0x88 {
            bytes 4;
            field mtc_acq_wr_data_3 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Write Data for Capture Memory Debug

                }
            }
        }
        register MTC_ACQ_WR_DATA_4 @0x8c {
            bytes 4;
            field mtc_acq_wr_data_4 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Write Data for Capture Memory Debug

                }
            }
        }
        register MTC_ACQ_WR_DATA_5 @0x90 {
            bytes 4;
            field mtc_acq_wr_data_5 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Write Data for Capture Memory Debug

                }
            }
        }
        register MTC_ACQ_WR_DATA_6 @0x94 {
            bytes 4;
            field reserved @'hc {
                bits 20;
            }
            field mtc_acq_wr_data_6 @'h0 {
                bits 12;
                access rw;
                hard_reset 'h0;
                doc {
                    Write Data for Capture Memory Debug

                }
            }
        }
        register MTC_ACQ_RD_DATA_0 @0x98 {
            bytes 4;
            field mtc_acq_rd_data_0 @'h0 {
                bits 32;
                access ro;
                volatile 1
                hard_reset 'h0;
                doc {
                    Read Data for Capture Memory Read back

                }
            }
        }
        register MTC_ACQ_RD_DATA_1 @0x9c {
            bytes 4;
            field mtc_acq_rd_data_1 @'h0 {
                bits 32;
                access ro;
                volatile 1
                hard_reset 'h0;
                doc {
                    Read Data for Capture Memory Read back

                }
            }
        }
        register MTC_ACQ_RD_DATA_2 @0xa0 {
            bytes 4;
            field mtc_acq_rd_data_2 @'h0 {
                bits 32;
                access ro;
                volatile 1
                hard_reset 'h0;
                doc {
                    Read Data for Capture Memory Read back

                }
            }
        }
        register MTC_ACQ_RD_DATA_3 @0xa4 {
            bytes 4;
            field mtc_acq_rd_data_3 @'h0 {
                bits 32;
                access ro;
                volatile 1
                hard_reset 'h0;
                doc {
                    Read Data for Capture Memory Read back

                }
            }
        }
        register MTC_ACQ_RD_DATA_4 @0xa8 {
            bytes 4;
            field mtc_acq_rd_data_4 @'h0 {
                bits 32;
                access ro;
                volatile 1
                hard_reset 'h0;
                doc {
                    Read Data for Capture Memory Read back

                }
            }
        }
        register MTC_ACQ_RD_DATA_5 @0xac {
            bytes 4;
            field mtc_acq_rd_data_5 @'h0 {
                bits 32;
                access ro;
                volatile 1
                hard_reset 'h0;
                doc {
                    Read Data for Capture Memory Read back

                }
            }
        }
        register MTC_ACQ_RD_DATA_6 @0xb0 {
            bytes 4;
            field reserved @'hc {
                bits 20;
            }
            field mtc_acq_rd_data_6 @'h0 {
                bits 12;
                access ro;
                volatile 1
                hard_reset 'h0;
                doc {
                    Read Data for Capture Memory Read back

                }
            }
        }
        register CFG_PRE_TRIG_CYCS @0x21c {
            bytes 4;
            field reserved @'h10 {
                bits 16;
            }
            field cfg_pre_trig_cycs @'h0 {
                bits 16;
                access rw;
                hard_reset 'h0;
                doc {
                    Defines the number of acq_en qualified cycles to skip before enabling storage for subsequent cycles.

                }
            }
        }
        register MTC_ACQ_ERROR_CNT @0x228 {
            bytes 4;
            field reserved @'ha {
                bits 22;
            }
            field mtc_acq_error_cnt @'h0 {
                bits 10;
                access ro;
                volatile 1
                hard_reset 'h0;
                doc {
                    Number of errors detected in the current acquisition.

                }
            }
        }
        register MTC_ACQ_ERROR_CNT_OVFL @0x234 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field mtc_acq_error_cnt_ovfl @'h0 {
                access ro;
                volatile 1
                hard_reset 'h0;
                doc {
                    The mtc_acq_error_cnt counter has overflowed.

                }
            }
        }
        register CFG_DATA_SEL_FIRST_ERROR @0x240 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field cfg_data_sel_first_error @'h0 {
                access rw;
                hard_reset 'h0;
                doc {
                    Select first byte lane with compressed error bus bit set for storage. Has priority over cfg_data_sel setting. Refer to the Memory Test Analyzer Core User Guide.

                }
            }
        }
        register MTC_ACQ_DATA_SEL @0x24c {
            bytes 4;
            field reserved @'h5 {
                bits 27;
            }
            field mtc_acq_data_sel @'h0 {
                bits 5;
                access ro;
                volatile 1
                hard_reset 'h0;
                doc {
                    When cfg_data_sel_first_error = 1'b1, the byte lane selected by the logic for compressed error bit storage is recorded in this register. Refer to the Memory Test Analyzer Core User Guide.

                }
            }
        }
    }
    block CA_PAR_ERR @0x8000 {
        bytes 4;
        register STAT_CA_PARITY_ERROR @0x0 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field stat_ca_parity_error @'h0 {
                access rc;
                volatile 1
                hard_reset 'h0;
                doc {
                    For DDR4: Asserts when an assertion is detected on the 'ALERT_n' pin. Each occurrence of a write CRC error or CA parity error will cause assertion of the DDR4 device 'ALERT_n' pin.

 For HBM: Asserts when an assertion is detected on the 'AERR' pin. Each occurrence of an address parity error will cause an assertion of the HBM device 'AERR' pin. 

 The value is cleared on read.

                }
            }
        }
    }
    block DFI @0x10000 {
        bytes 4;
        register CFG_DFI_T_RDDATA_EN @0x0 {
            bytes 4;
            field reserved @'h6 {
                bits 26;
            }
            field cfg_dfi_t_rddata_en @'h0 {
                bits 6;
                access rw;
                hard_reset 'h12;
                doc {
                    Used to derive the delay from assertion of read command to dfi_rddata_en assertion at the DFI interface.  The resulting delay, referred to as tRDDATA_EN in the DFI specification, is calculated below (all values specified in memory clocks).

 Full-Rate: CAS read latency + Additive Latency + Parity Latency (DDR4 only) + Command Address Latency (DDR4 only) + cfg_regdimm + cfg_dfi_t_rddata_en - 9

 Half-Rate: CAS read latency + Additive Latency + Parity Latency (DDR4 only) + Command Address Latency (DDR4 only) + cfg_regdimm + cfg_dfi_t_rddata_en - 19

 Quarter-Rate: CAS read latency + Additive Latency + Parity Latency (DDR4 only) + Command Address Latency (DDR4 only) + cfg_regdimm + cfg_dfi_t_rddata_en - 36

 This value is typically established as a constant for a particular PHY and is not intended to be changed from its reset value. Since the tRDDATA_EN that the controller generates is a function of the programmed latencies, cfg_dfi_t_rddata_en does not need to be reprogrammed whenever the latencies are changed.

                }
            }
        }
        register CFG_DFI_T_PHY_RDLAT @0x4 {
            bytes 4;
            field reserved @'h5 {
                bits 27;
            }
            field cfg_dfi_t_phy_rdlat @'h0 {
                bits 5;
                access rw;
                hard_reset 'h8;
                doc {
                    Number of memory clocks from assertion of dfi_rddata_en to dfi_rddata_valid assertion. This parameter is only valid for PHY configurations where the dfi_rddata_valid is generated within the controller and the dfi_rddata_valid from the PHY is unused or unavailable. When the controller is generating the dfi_rddata_valid, this value is set based on PHY requirements.

                }
            }
        }
        register CFG_DFI_T_PHY_WRLAT @0x8 {
            bytes 4;
            field reserved @'h6 {
                bits 26;
            }
            field cfg_dfi_t_phy_wrlat @'h0 {
                bits 6;
                access rw;
                hard_reset 'h5;
                doc {
                    Used to derive the delay from assertion of the write command to dfi_wrdata_en assertion at the DFI interface. The resulting delay, referred to as tPHY_WRLAT in the DFI specification, is calculated below (all values specified in memory clocks).

 Full-Rate: CAS write latency + Additive Latency + Parity Latency (DDR4 only) + Command Address Latency (DDR4 only) + cfg_regdimm + cfg_dfi_t_phy_wrlat - 3
 
 Half-Rate: CAS write latency + Additive Latency + Parity Latency (DDR4 only) + Command Address Latency (DDR4 only) + cfg_regdimm + cfg_dfi_t_phy_wrlat - 6
 
 Quarter-Rate: CAS write latency + Additive Latency + Parity Latency (DDR4 only) + Command Address Latency (DDR4 only) + cfg_regdimm + cfg_dfi_t_phy_wrlat - 12
 
 This value is typically established as a constant for a particular PHY and is not intended to be changed from its reset value. Since the tPHY_WRLAT that the controller generates is a function of the programmed latencies, cfg_dfi_phy_wrlat does not need to be reprogrammed whenever the latencies are changed.

                }
            }
        }
        register CFG_DFI_PHYUPD_EN @0xc {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field cfg_dfi_phyupd_en @'h0 {
                access rw;
                hard_reset 'h1;
                doc {
                    For PHYs using dfi_phyupd_req, this register can configure the PHY not to assert requests during initialization or test sequences where the update requests could cause interference with the controller.

                }
            }
        }
        register INIT_DFI_LP_DATA_REQ @0x10 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field init_dfi_lp_data_req @'h0 {
                access rw;
                hard_reset 'h0;
                doc {
                    Value applied to dfi_lp_data_req on DFI interface to PHY.

                }
            }
        }
        register INIT_DFI_LP_CTRL_REQ @0x14 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field init_dfi_lp_ctrl_req @'h0 {
                access rw;
                hard_reset 'h0;
                doc {
                    Value applied to dfi_lp_ctrl_req on DFI interface to PHY.

                }
            }
        }
        register STAT_DFI_LP_ACK @0x18 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field stat_dfi_lp_ack @'h0 {
                access rc;
                volatile 1
                hard_reset 'h0;
                doc {
                    Status of dfi_lp_ack on DFI interface from PHY.

                }
            }
        }
        register INIT_DFI_LP_WAKEUP @0x1c {
            bytes 4;
            field reserved @'h4 {
                bits 28;
            }
            field init_dfi_lp_wakeup @'h0 {
                bits 4;
                access rw;
                hard_reset 'h0;
                doc {
                    Value applied to dfi_lp_wakeup on DFI interface to PHY.

                }
            }
        }
        register INIT_DFI_DRAM_CLK_DISABLE @0x20 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field init_dfi_dram_clk_disable @'h0 {
                access rw;
                hard_reset 'h0;
                doc {
                    Value applied to dfi_dram_clk_disable on DFI interface to PHY.

                }
            }
        }
        register STAT_DFI_TRAINING_ERROR @0x24 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field stat_dfi_training_error @'h0 {
                access ro;
                volatile 1
                hard_reset 'h0;
                doc {
                    Status of dfi_training_error on DFI interface from PHY.

                }
            }
        }
        register STAT_DFI_ERROR @0x28 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field stat_dfi_error @'h0 {
                access rc;
                volatile 1
                hard_reset 'h0;
                doc {
                    Status of dfi_error on DFI interface from PHY.

                }
            }
        }
        register STAT_DFI_ERROR_INFO @0x2c {
            bytes 4;
            field reserved @'h4 {
                bits 28;
            }
            field stat_dfi_error_info @'h0 {
                bits 4;
                access ro;
                volatile 1
                hard_reset 'h0;
                doc {
                    Status of dfi_error_info on DFI interface from PHY.

                }
            }
        }
        register CFG_DFI_DATA_BYTE_DISABLE @0x30 {
            bytes 4;
            field reserved @'h10 {
                bits 16;
            }
            field cfg_dfi_data_byte_disable @'h0 {
                bits 16;
                access rw;
                hard_reset 'h0;
                doc {
                    Value applied to dfi_data_byte_disable on DFI interface to PHY.

                }
            }
        }
        register STAT_DFI_INIT_COMPLETE @0x34 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field stat_dfi_init_complete @'h0 {
                access ro;
                volatile 1
                hard_reset 'h0;
                doc {
                    Status of dfi_init_complete on DFI interface from PHY.

                }
            }
        }
        register STAT_DFI_TRAINING_COMPLETE @0x38 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field stat_dfi_training_complete @'h0 {
                access ro;
                volatile 1
                hard_reset 'h0;
                doc {
                    Status of dfi_training_complete on DFI interface from PHY.

                }
            }
        }
        register CFG_DFI_LVL_SEL @0x3c {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field cfg_dfi_lvl_sel @'h0 {
                access rw;
                hard_reset 'h0;
                doc {
                    Mux select for dfi_lvl_periodic and dfi_lvl_pattern. 
 
 0 - PHY initialization module controls signals
 
 1 - CSR control

                }
            }
        }
        register CFG_DFI_LVL_PERIODIC @0x40 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field cfg_dfi_lvl_periodic @'h0 {
                access rw;
                hard_reset 'h0;
                doc {
                    Training length indicator.

                }
            }
        }
        register CFG_DFI_LVL_PATTERN @0x44 {
            bytes 4;
            field reserved @'h4 {
                bits 28;
            }
            field cfg_dfi_lvl_pattern @'h0 {
                bits 4;
                access rw;
                hard_reset 'h0;
                doc {
                    Training pattern used for read training.

                }
            }
        }
        register STAT_DFI_TCR_TEMP @0x48 {
            bytes 4;
            field reserved @'h3 {
                bits 29;
            }
            field stat_dfi_tcr_temp @'h0 {
                bits 3;
                access ro;
                volatile 1
                hard_reset 'h0;
                doc {
                    HBM memory device temperature status (see HBM2 JEDEC specification)

                }
            }
        }
        register STAT_DFI_CATTRIP @0x4c {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field stat_dfi_cattrip @'h0 {
                access ro;
                volatile 1
                hard_reset 'h0;
                doc {
                    HBM memory device catastrophic temperature trip (see HBM2 JEDEC specification)

                }
            }
        }
        register PHY_DFI_INIT_START @0x50 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field phy_dfi_init_start @'h0 {
                access rw;
                hard_reset 'h0;
                doc {
                    Set the init start signal into the PHY

                }
            }
        }
        register INIT_DFI_TRAINING_COMPLETE @0x58 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field init_dfi_training_complete @'h0 {
                access rw;
                hard_reset 'h0;
                doc {
                    To be used by software to let memory controller know that PHY training has completed.  This signal is OR'd with dfi_training_complete from PHY.

                }
            }
        }
    }
    block AXI_IF @0x12c00 {
        bytes 4;
        register CFG_AXI_START_ADDRESS_AXI1_0 @0x18 {
            bytes 4;
            field cfg_axi_start_address_axi1_0 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Sets the lower valid AXI address boundary for this AXI Interface. The AXI Interface Core will respond with a DECERR (decode error) response to AXI read and write requests with an address value less than this port setting. The Verilog parameter ADDR_MAP_SIG_BITS sets the number of significant bits that are used in the address value comparison.  

                }
            }
        }
        register CFG_AXI_START_ADDRESS_AXI1_1 @0x1c {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field cfg_axi_start_address_axi1_1 @'h0 {
                access rw;
                hard_reset 'h0;
                doc {
                    Sets the lower valid AXI address boundary for this AXI Interface. The AXI Interface Core will respond with a DECERR (decode error) response to AXI read and write requests with an address value less than this port setting. The Verilog parameter ADDR_MAP_SIG_BITS sets the number of significant bits that are used in the address value comparison.  

                }
            }
        }
        register CFG_AXI_END_ADDRESS_AXI1_0 @0x318 {
            bytes 4;
            field cfg_axi_end_address_axi1_0 @'h0 {
                bits 32;
                access rw;
                hard_reset 'hffffffff;
                doc {
                    Sets the upper valid AXI address boundary for this AXI Interface. The AXI Interface Core will respond with a DECERR (decode error) response to AXI read and write requests with an address value greater than this port setting. The Verilog parameter ADDR_MAP_SIG_BITS sets the number of significant bits that are used in the address value comparison.  

                }
            }
        }
        register CFG_AXI_END_ADDRESS_AXI1_1 @0x31c {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field cfg_axi_end_address_axi1_1 @'h0 {
                access rw;
                hard_reset 'h1;
                doc {
                    Sets the upper valid AXI address boundary for this AXI Interface. The AXI Interface Core will respond with a DECERR (decode error) response to AXI read and write requests with an address value greater than this port setting. The Verilog parameter ADDR_MAP_SIG_BITS sets the number of significant bits that are used in the address value comparison.  

                }
            }
        }
        register CFG_MEM_START_ADDRESS_AXI1_0 @0x618 {
            bytes 4;
            field cfg_mem_start_address_axi1_0 @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    Memory controller address offset for this AXI Interface. The value of cfg_mem_start_address is subtracted off of every AXI read and write request before being submitted to the memory controller.  

                }
            }
        }
        register CFG_MEM_START_ADDRESS_AXI1_1 @0x61c {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field cfg_mem_start_address_axi1_1 @'h0 {
                access rw;
                hard_reset 'h0;
                doc {
                    Memory controller address offset for this AXI Interface. The value of cfg_mem_start_address is subtracted off of every AXI read and write request before being submitted to the memory controller.  

                }
            }
        }
        register CFG_ENABLE_BUS_HOLD_AXI1 @0x914 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field cfg_enable_bus_hold_axi1 @'h0 {
                access rw;
                hard_reset 'h0;
                doc {
                    For this AXI Interface, enables bus hold function that will stop arbitration in the MPFE when the read reorder buffer is full

                }
            }
        }
        register CFG_AXI_AUTO_PCH @0xa90 {
            bytes 4;
            field cfg_axi_auto_pch @'h0 {
                bits 32;
                access rw;
                hard_reset 'h0;
                doc {
                    This is AXI interface register that can be configured to be 8, 16, or 32 bits wide depending upon the number of AXI ports supported. Bit 0 of this register is always associated with axi port 0, bit 1 with axi port 1, etc.  If port Y uses a local bus interface, then cfg_axi_auto_pch[Y] is not used and is considered a don't care.  If it is an axi port input, cfg_axi_auto_pch serves solely as the auto_pch control for that AXI port. When cfg_axi_auto_pch is set and a long (multibeat) AXI read or write is issued by user logic, then the NWL axi interface logic will insure that only the last sdram controller request being issued (on behalf of a single long AXI request) asserts auto_precharge.   If a reorder core is included and is enabled (cfg_reorder_queue_en = 1), then cfg_ro_closed_page_policy, when set,  overrides the cfg_axi_auto_pch input and forces auto_pch asserted on all outgoing requests from the reoder core. 

                }
            }
        }
    }
    block csr_custom @0x3c000 {
        bytes 4;
        register PHY_RESET_CONTROL @0x0 {
            bytes 4;
            field reserved @'h10 {
                bits 16;
            }
            field phy_reset_control @'h0 {
                bits 16;
                access rw;
                hard_reset 'hd;
                doc {
                    Reset control register
                }
            }
        }
        register PHY_PC_RANK @0x4 {
            bytes 4;
            field reserved @'h4 {
                bits 28;
            }
            field phy_pc_rank @'h0 {
                bits 4;
                access rw;
                hard_reset 'h0;
                doc {
                    Select which rank to be trained.
                }
            }
        }
        register PHY_RANKS_TO_TRAIN @0x8 {
            bytes 4;
            field reserved @'h10 {
                bits 16;
            }
            field phy_ranks_to_train @'h0 {
                bits 16;
                access rw;
                hard_reset 'h0;
                doc {
                    One hot encoding of which ranks to train during automatic initialization.
                }
            }
        }
        register PHY_WRITE_REQUEST @0xc {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field phy_write_request @'h0 {
                access rw;
                hard_reset 'h0;
                doc {
                    Request the memory controller to write to the SDRAM. Writes the eye training pattern into location 0 in the SDRAM
                }
            }
        }
        register PHY_WRITE_REQUEST_DONE @0x10 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field phy_write_request_done @'h0 {
                access rc;
                volatile 1
                hard_reset 'h0;
                doc {
                    Indicate write request is completed
                }
            }
        }
        register PHY_READ_REQUEST @0x14 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field phy_read_request @'h0 {
                access rw;
                hard_reset 'h0;
                doc {
                    Request the memory controller to read from the SDRAM. Intended for gate training and eye training
                }
            }
        }
        register PHY_READ_REQUEST_DONE @0x18 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field phy_read_request_done @'h0 {
                access rc;
                volatile 1
                hard_reset 'h0;
                doc {
                    Indicate read request is completed
                }
            }
        }
        register PHY_WRITE_LEVEL_DELAY @0x1c {
            bytes 4;
            field reserved @'h6 {
                bits 26;
            }
            field phy_write_level_delay @'h0 {
                bits 6;
                access rw;
                hard_reset 'h0;
                doc {
                    Number of cycles to allow PHY response before sending another strobe.
                }
            }
        }
        register PHY_GATE_TRAIN_DELAY @0x20 {
            bytes 4;
            field reserved @'h6 {
                bits 26;
            }
            field phy_gate_train_delay @'h0 {
                bits 6;
                access rw;
                hard_reset 'h0;
                doc {
                    Number of cycles to allow PHY response before sending the next read command.
                }
            }
        }
        register PHY_EYE_TRAIN_DELAY @0x24 {
            bytes 4;
            field reserved @'h6 {
                bits 26;
            }
            field phy_eye_train_delay @'h0 {
                bits 6;
                access rw;
                hard_reset 'h0;
                doc {
                    Number of cycles to allow PHY response before sending the next read command.
                }
            }
        }
        register PHY_EYE_PAT @0x28 {
            bytes 4;
            field reserved @'h8 {
                bits 24;
            }
            field phy_eye_pat @'h0 {
                bits 8;
                access rw;
                hard_reset 'h0;
                doc {
                    Eye training pattern to be loaded into the phy and the SDRAM
                }
            }
        }
        register PHY_START_RECAL @0x2c {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field phy_start_recal @'h0 {
                access rw;
                hard_reset 'h0;
                doc {
                    Rerun write leveling, gate training, and eye training. 
                }
            }
        }
        register PHY_CLR_DFI_LVL_PERIODIC @0x30 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field phy_clr_dfi_lvl_periodic @'h0 {
                access rw;
                hard_reset 'h0;
                doc {
                    Clear PHY init SM Periodic Training incremental enable
                }
            }
        }
        register PHY_TRAIN_STEP_ENABLE @0x34 {
            bytes 4;
            field reserved @'h6 {
                bits 26;
            }
            field phy_train_step_enable @'h0 {
                bits 6;
                access rw;
                hard_reset 'h0;
                doc {
                    PHY init state machine training step/stage enables, [5]: CA training, [4]: write leveling, [3]: read leveling, [2:0]: reserved
                }
            }
        }
        register PHY_LPDDR_DQ_CAL_PAT @0x38 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field phy_lpddr_dq_cal_pat @'h0 {
                access rw;
                hard_reset 'h0;
                doc {
                    LPDDR2/3 DQ training pattern, 0:A,1010_1010,MR32  1:B,0011_0011,MR40
                }
            }
        }
        register PHY_INDPNDT_TRAINING @0x3c {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field phy_indpndt_training @'h0 {
                access rw;
                hard_reset 'h0;
                doc {
                    Set to 1'b1 to indicate that the PHY will perform training without requiring interaction from the MC.  The PHY will start training at the assertion of ctrlr_init_done and will signal completion with dfi_training_complete.
                }
            }
        }
        register PHY_ENCODED_QUAD_CS @0x40 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field phy_encoded_quad_cs @'h0 {
                access rw;
                hard_reset 'h0;
                doc {
                    Set to indicate configuration with DDR4 RDIMMs that have four ranks that encode chip-select down to 3 bits. When this port is set to '1', sd_cs_n[2:0] will only be used to designate rank selection to the RCD device.  Refer to the JEDEC DDR4RCD01 DDR4 Registering Clock Driver (RCD) specification for details on how the Encoded Quad CS is used in an RDIMM application.
                }
            }
        }
        register PHY_HALF_CLK_DLY_ENABLE @0x44 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field phy_half_clk_dly_enable @'h0 {
                access rw;
                hard_reset 'h0;
                doc {
                    Set to enable 1/2 clock output delay of DQ/DQS datapath.  Used to Align with RCD 1/2 clock delay.
                }
            }
        }
        register RB_PHY_FREQ @0x48 {
            bytes 4;
            field reserved @'h5 {
                bits 27;
            }
            field rb_phy_freq @'h0 {
                bits 5;
                access rw;
                hard_reset 'hf;
                doc {
                    See 'FREQ' in Rambus PHY Specification
                }
            }
        }
        register RB_PHY_PLL_BYPASS @0x4c {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field rb_phy_pll_bypass @'h0 {
                access rw;
                hard_reset 'h0;
                doc {
                    See 'PLLBYPASS' in Rambus PHY Specification
                }
            }
        }
        register RB_PHY_PLL_ON @0x50 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field rb_phy_pll_on @'h0 {
                access rw;
                hard_reset 'h1;
                doc {
                    See 'PLLON' in Rambus PHY Specification
                }
            }
        }
        register RB_PHY_AWORD_EN @0x54 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field rb_phy_aword_en @'h0 {
                access rw;
                hard_reset 'h1;
                doc {
                    See 'CmAWORDEN' in Rambus PHY Specification
                }
            }
        }
        register RB_PHY_RR_EN @0x58 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field rb_phy_rr_en @'h0 {
                access rw;
                hard_reset 'h0;
                doc {
                    See 'CmRREN' in Rambus PHY Specification
                }
            }
        }
        register RB_PHY_RC_EN @0x5c {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field rb_phy_rc_en @'h0 {
                access rw;
                hard_reset 'h0;
                doc {
                    See 'CmRCEN' in Rambus PHY Specification
                }
            }
        }
        register RB_PHY_AERR_EN @0x60 {
            bytes 4;
            field reserved @'h1 {
                bits 31;
            }
            field rb_phy_aerr_en @'h0 {
                access rw;
                hard_reset 'h1;
                doc {
                    See 'CmAERREN' in Rambus PHY Specification
                }
            }
        }
        register RB_PHY_DM_EN @0x64 {
            bytes 4;
            field reserved @'h4 {
                bits 28;
            }
            field rb_phy_dm_en @'h0 {
                bits 4;
                access rw;
                hard_reset 'hf;
                doc {
                    See 'DmDWnDMEN' in Rambus PHY Specification
                }
            }
        }
        register RB_PHY_DBI_EN @0x68 {
            bytes 4;
            field reserved @'h4 {
                bits 28;
            }
            field rb_phy_dbi_en @'h0 {
                bits 4;
                access rw;
                hard_reset 'hf;
                doc {
                    See 'DmDWnDBIEN' in Rambus PHY Specification
                }
            }
        }
        register RB_PHY_PAR_EN @0x6c {
            bytes 4;
            field reserved @'h4 {
                bits 28;
            }
            field rb_phy_par_en @'h0 {
                bits 4;
                access rw;
                hard_reset 'hf;
                doc {
                    See 'DmDWnPAREN' in Rambus PHY Specification
                }
            }
        }
        register RB_PHY_RD_EN @0x70 {
            bytes 4;
            field reserved @'h8 {
                bits 24;
            }
            field rb_phy_rd_en @'h0 {
                bits 8;
                access rw;
                hard_reset 'h0;
                doc {
                    See 'DmDWnRDEN' in Rambus PHY Specification
                }
            }
        }
    }
}

